
# WA Fish Biology methods package
# Alex Hesp - Department of Primary Industries and Regional Development

# **************************
# General plotting functions
# **************************

# get maximum and minimum y values and y interval
Get_yaxis_scale <- function(y_data) {

  xx = floor(log10(max(y_data)))
  ymin = floor(min(0.8 * y_data))
  temp_ymax = ceiling(max(1.2 * y_data))
  temp_ymax2 = round(temp_ymax, -xx)
  xxx = (temp_ymax2-ymin)/4
  yint = round(xxx, -xx)
  ymax = ymin + (4 * yint)

  results = list(ymin = ymin,
                 ymax = ymax,
                 yint = yint)

  return(results)
}

# get maximum and minimum x values and x interval
Get_xaxis_scale <- function(x_data) {

  xx = floor(log10(max(x_data)))
  temp_xmin = floor(min(0.8 * x_data))
  xmin = round(temp_xmin, -xx)
  temp_xmax = ceiling(1.2*max(x_data))
  temp_xmax2 = round(temp_xmax, -xx)
  xint = (temp_xmax2-xmin)/4
  xmax = xmin + (4 * xint)
  results = list(xmin = xmin,
                 xmax = xmax,
                 xint = xint)


  return(results)
}




#***********************************
# Parameter transformation functions
#***********************************

# These two routines were provided by Ainslie Denham, July 2020.
# inverse logistic transformation (keeps values between 0 and 1),
# applied in mixture distribution analyses, for estimated proportions
ilogit <- function(x) {
  result = 1/(1+exp(-x))
  return(result)
}

# logistic transformation
logit <- function(x) {
  result = log(x/(1-x))
  return(result)
}


#******************************
# Mixture distribution analyses
#******************************


# function for distributions
EstPropAtLen_MixtureDistn <- function(params) {

  if (length(which(c(2,4,5,8) == length(params))) == 0) {
    stop("Problem: not correct number of parameters")
  }

  # determine number of cohorts to be fitted, based on specified number of starting parameters
  if (length(params) == 2) {
    Cohorts=1
    if (DistnType == 1) { # normal
      Mean1 = exp(params[1])
      sd1 = exp(params[2])
    }
    if (DistnType == 2) { # gamma
      shape1 = exp(params[1])
      rate1 = exp(params[2])
    }
  }
  if (length(params) == 4) { # 2 cohorts with common sd or rate
    Cohorts=2
    if (DistnType == 1) { # normal
      Mean1 = exp(params[1])
      Mean2 = exp(params[2])
      sd1 = exp(params[3])
      sd2 = sd
    }
    if (DistnType == 2) { # gamma
      shape1 = exp(params[1])
      shape2 = exp(params[2])
      rate1 = exp(params[3])
      rate2 = rate1
    }
    PropZero = ilogit(params[4]) # 2 cohorts with separate sds
  }
  if (length(params) == 5) {
    Cohorts=2
    if (DistnType == 1) { # normal
      Mean1 = exp(params[1])
      Mean2 = exp(params[2])
      sd1 = exp(params[3])
      sd2 = exp(params[4])
    }
    if (DistnType == 2) { # gamma
      shape1 = exp(params[1])
      shape2 = exp(params[2])
      rate1 = exp(params[3])
      rate2 = exp(params[4])
    }
    PropZero = ilogit(params[5])
  }
  if (length(params) == 8) {
    Cohorts=3
    if (DistnType == 1) { # normal
      Mean1 = exp(params[1])
      Mean2 = exp(params[2])
      Mean3 = exp(params[3])
      sd1 = exp(params[4])
      sd2 = exp(params[5])
      sd3 = exp(params[6])
    }
    if (DistnType == 2) { # gamma
      shape1 = exp(params[1])
      shape2 = exp(params[2])
      shape3 = exp(params[3])
      rate1 = exp(params[4])
      rate2 = exp(params[5])
      rate3 = exp(params[6])
    }
    PropZero = ilogit(params[7])
    PropOne = ilogit(params[8])
  }

  # get expected lengths for each cohort, and overall
  LbndSizeCl <- seq(MinSize, MaxSize-SizeInt, SizeInt)
  UbndSizeCl <- seq(SizeInt, MaxSize, SizeInt)
  Penalty1=0; Penalty2=0
  expfreq1=rep(NA,length(ObsFreq)); expfreq2=rep(NA,length(ObsFreq)); expfreq3=rep(NA,length(ObsFreq))

  if (Cohorts==1) {
    if (DistnType == 1) { # normal
      expfreq1 = (pnorm(UbndSizeCl, Mean1, sd1) -
                    pnorm(LbndSizeCl, Mean1, sd1)) * sum(ObsFreq)
    }
    if (DistnType == 2) { # gamma
      expfreq1 = (pgamma(UbndSizeCl, shape1, rate1) -
                    pgamma(LbndSizeCl, shape1, rate1)) * sum(ObsFreq)
    }
    sum_expfreq <- expfreq1 / sum(expfreq1)
  } # 1 cohort

  if (Cohorts==2) {

    # don't allow mean2 to be less than mean1 + 2mm
    if (DistnType == 1) { # normal
    if ((Mean2 - Mean1) < 2) {
      Penalty1 = 10 * (Mean2 - Mean1 - 2) ^ 2
      Mean2 = Mean1 + 2
    }
    }

    height1 <- sum(ObsFreq) * PropZero
    height2 <- sum(ObsFreq) * (1-PropZero)
    if (DistnType == 1) { # normal
      expfreq1 <- (pnorm(UbndSizeCl, Mean1, sd1) - pnorm(LbndSizeCl, Mean1, sd1)) * height1
      expfreq2 <- (pnorm(UbndSizeCl, Mean2, sd2) - pnorm(LbndSizeCl, Mean2, sd2)) * height2
    }
    if (DistnType == 2) { # gamma
      expfreq1 <- (pgamma(UbndSizeCl, shape1, rate1) - pgamma(LbndSizeCl, shape1, rate1)) * height1
      expfreq2 <- (pgamma(UbndSizeCl, shape2, rate2) - pgamma(LbndSizeCl, shape2, rate2)) * height2
    }
    sum_expfreq <- expfreq1 + expfreq2
  } # 2 cohorts

  if (Cohorts==3) {

    # don't allow mean2 to be less than mean1 + 2mm
    if (DistnType == 1) { # normal
    if ((Mean2 - Mean1) < 2) {
      Penalty1 = 10 * (Mean2 - Mean1 - 2) ^2
      Mean2 = Mean1 + 2
    }
    # don't allow mean3 to be less than mean2 + 2mm
    if ((Mean3 - Mean2) < 2) {
      Penalty1 = Penalty1 + (10 * (Mean3 - Mean2 - 2) ^2)
      Mean2 = Mean1 + 2
    }
    }
    # ensure sum of proportions is not > 1
    if ((PropZero + PropOne)  > 1.0) {
      Penalty2= 1000 * ((PropZero + PropOne) - 1.0) ^2
      PropZero = PropZero / ((PropZero + PropOne))
      PropOne = 1 - PropZero
      PropZero = 0.999 * PropZero
      PropOne = 0.999 * PropOne
    }

    height1 <- sum(ObsFreq) * PropZero
    height2 <- sum(ObsFreq) * PropOne
    height3 <- sum(ObsFreq) * (1 - PropZero - PropOne)
    if (DistnType == 1) { # normal
      expfreq1 <- (pnorm(UbndSizeCl, Mean1, sd1) - pnorm(LbndSizeCl, Mean1, sd1)) * height1
      expfreq2 <- (pnorm(UbndSizeCl, Mean2, sd2) - pnorm(LbndSizeCl, Mean2, sd2)) * height2
      expfreq3 <- (pnorm(UbndSizeCl, Mean3, sd3) - pnorm(LbndSizeCl, Mean3, sd3)) * height3
    }
    if (DistnType == 2) { # gamma
      expfreq1 <- (pgamma(UbndSizeCl, shape1, rate1) - pgamma(LbndSizeCl, shape1, rate1)) * height1
      expfreq2 <- (pgamma(UbndSizeCl, shape2, rate2) - pgamma(LbndSizeCl, shape2, rate2)) * height2
      expfreq3 <- (pgamma(UbndSizeCl, shape3, rate3) - pgamma(LbndSizeCl, shape3, rate3)) * height3
    }
    sum_expfreq <- expfreq1 + expfreq2 + expfreq3
  } # 3 cohorts

  # get overall expected proportions and frequencies at length
  ExpPropAtLen = sum_expfreq / sum(sum_expfreq)
  ExpFreqAtLen = ExpPropAtLen * sum(ObsFreq)


  if (Cohorts==1) {
    results = list(EstPropZero = NA,
                   EstPropOne = NA,
                   expfreq1 = expfreq1,
                   expfreq2 = NA,
                   expfreq3 = NA,
                   ExpPropAtLen = ExpPropAtLen,
                   ExpFreqAtLen = ExpFreqAtLen,
                   Penalty1 = Penalty1,
                   Penalty2 = Penalty2)
  }
  if (Cohorts==2) {
    results = list(EstPropZero = PropZero,
                   EstPropOne = NA,
                   expfreq1 = expfreq1,
                   expfreq2 = expfreq2,
                   expfreq3 = NA,
                   ExpPropAtLen = ExpPropAtLen,
                   ExpFreqAtLen = ExpFreqAtLen,
                   Penalty1 = Penalty1,
                   Penalty2 = Penalty2)
  }
  if (Cohorts==3) {
    results = list(EstPropZero = PropZero,
                   EstPropOne = PropOne,
                   expfreq1 = expfreq1,
                   expfreq2 = expfreq2,
                   expfreq3 = expfreq3,
                   ExpPropAtLen = ExpPropAtLen,
                   ExpFreqAtLen = ExpFreqAtLen,
                   Penalty1 = Penalty1,
                   Penalty2 = Penalty2)
  }

  return(results)

} # end function


#' Calculate negative log-likelihood associated with the fit of a size mixture distribution model
#' and associated parameters values to size frequency data
#'
#' Calculates the negative log-likelihood associated with the fit of a size mixture
#' distribution model and associated parameters values to size frequency data,
#' with 1, 2 or 3 size modes. The model assumes each size mode is normally-distributed.
#' Four alternative models are available depending on the number of modes present in the
#' data, and assumptions regarding the spread of the various size modes.
#' Function requires size frequency data, and values for minimum size, maximum size
#' and size interval (stored in memory in R).
#' ObsFreq (Numeric Vector), MinSize, MaxSize, SizeInt (Numbers).
#' This function (with parameter inputs) can be passed into R optimisation routines (e.g. nlminb).
#' @keywords internal
#' @param params Mean1, sd1 (Model 1: 1 size mode),
#' Mean1, Mean2, sd1, PropZero (Model 2: 2 size modes with common sd),
#' Mean1, Mean2, sd1, sd2, PropZero, (Model 3: 2 size modes with separate sds),
#' Mean1, Mean2, Mean3, sd1, sd2, sd3, PropZero, PropOne (Model 4: 3 size modes with separate sds)
#' Numbers.
#' @return Negative log-likelihood associated with mixture model fit to size frequency data
CalcNLL_SizeMixtureDistn <- function(params) {

  # get expected proportions at length, for each cohort
  Res = EstPropAtLen_MixtureDistn(params)

  ExpPropAtLen = Res$ExpPropAtLen
  Penalty1 = Res$Penalty1
  Penalty2 = Res$Penalty2

  # calculate the multinomial likelihood
  NLL = -sum(ObsFreq * log(ExpPropAtLen + 0.0001)) + Penalty1 + Penalty2
  # cat("NLL",NLL,"Penalty1",Penalty1,"Penalty2",Penalty2,'\n')
  results <- NLL

  return(results)

} # end function


#' Fit a size mixture distribution model to size frequency data
#'
#' This function fits a size mixture distribution model to size frequency data
#' by minimising the negative log-likelihood associated with the parameters and data, using nlminb.
#' Function requires size frequency data (stored in memory in R), ObsFreq (Numeric Vector).
#' @keywords internal
#' @param params (Vectors)
#' Mean1, sd1 (Model 1 normal distribution: 1 size mode),
#' Shape1, Rate1 (Model 1 gamma distribution: 1 size mode),
#' Mean1, Mean2, sd1, PropZero (Model 2 normal distribution: 2 size modes with common sd),
#' Shape1, Shape2, Rate1, PropZero (Model 2 gamma distribution: 2 size modes with common sd),
#' Mean1, Mean2, sd1, sd2, PropZero, (Model 3 normal distribution: 2 size modes with separate sds),
#' Shape, Shape2, Rate1, Rate2, PropZero, (Model 3 gamma distribution: 2 size modes with separate sds),
#' Mean1, Mean2, Mean3, sd1, sd2, sd3, PropZero, PropOne (Model 4 normal distribution: 3 size modes with separate sds)
#' Shape1, Shape2, Shape3, Rate1, Rate2, Rate3, PropZero, PropOne (Model 4 gamma distribution: 3 size modes with separate sds)
#' DistnType (1=normal, 2=gamma, Integer), Cohorts (1, 2 or 3, Integer), MinSize (Integer),
#' MaxSize (Integer), SizeInt (Number), observed frequencies in length classes, ObsFreq (Vector)
#' @return nlmb (stored output from internal R nlminb optimisation function)
FitMixtureDistnModel <- function(params, DistnType, Cohorts, MinSize, MaxSize, SizeInt, ObsFreq) {

  nlmb <- nlminb(params, CalcNLL_SizeMixtureDistn, gradient = NULL,
                 hessian = TRUE,  control=list(trace=1))

  results=nlmb
  return(results)
}

#' Get statistical outputs from a fitted size mixture distribution model
#'
#' This function fits a size mixture distribution model to size frequency data
#' by minimising the negative log-likelihood associated with the parameters and data, using nlminb.
#' It provides various statistical outputs in include convergence statistics, parameter estimated
#' and associated 95 calculated using the MASS package.
#' Function requires size frequency data (stored in memory in R), ObsFreq (Numeric Vector).
#' @param Mean1, sd1 (Model 1 with normal distribution: 1 size mode),
#' Shape1, Shape1 (Model 1 with gamma distribution: 1 size mode),
#' Mean1, Mean2, sd1, PropZero (Model 2 with normal distribution: 2 size modes with common sd),
#' Shape1, Shape2, Rate1, PropZero (Model 2 with gamma distribution: 2 size modes with common sd),
#' Mean1, Mean2, sd1, sd2, PropZero, (Model 3 with normal distribution: 2 size modes with separate sds),
#' Shape1, Shape2, Rate1, Rate2, PropZero, (Model 3 with gamma distribution: 2 size modes with separate sds),
#' Mean1, Mean2, Mean3, sd1, sd2, sd3, PropZero, PropOne (Model 4 with normal distribution: 3 size modes with separate sds)
#' Shape1, Shape2, Shape3, Rate1, Rate2, Rate3, PropZero, PropOne (Model 4 with gamma distribution: 3 size modes with separate sds)
#' Numbers.
#' @return negative log-likelihood (nll), nlminb convergence diagnostic (convergence),
#'  sample size (SampleSize), estimates of model parameters with lower and upper 95
#'  confidence limits (ParamEst), Estimates of standard deviations for estimated mean
#'  (normal distribution assumption) or shape parameters (gamma distribution assumption) for
#'  each fitted size mode (EstMean1_sd, EstMean2_sd, EstMean3_sd), point estimates
#'  for model parameters (params) and variance-covariance matrix (vcov.params),
#'  expected frequency for cohorts 1, 2 and 3 (expfreq1, expfreq2, expfreq3),
#'  overall expected proportions at length across all cohorts (ExpPropAtLen), and
#'  overall expected frequencies at length,across all cohorts (ExpFreqAtLen).
#' @examples
#' Simulate data with 1 mode, specifying normal distribution
#' set.seed(123)
#' MinSize = 0
#' MaxSize = 60
#' SizeInt = 1
#' SampSize = 1000
#' Cohorts=1
#' Mean1 = 20
#' sd1 = 5
#' ObsSize = round(rnorm(SampSize, Mean1, sd1),0)
#' HistData=hist(ObsSize, breaks=seq(0,MaxSize,SizeInt), right=FALSE, plot=FALSE)
#' ObsFreq = HistData$counts
#' # Specify starting parameter values for Mean1 and sd1, and return associated negative log-likelihood
#' DistnType = 1 # 1=normal, 2=gamma
#' params = log(c(30, 5)) # normal
#' GetMixtureModelResults(params, DistnType, Cohorts, MinSize, MaxSize, SizeInt, ObsFreq)
#' # Simulate data with 1 mode, specifying gamma distribution
#' set.seed(123)
#' MinSize = 0
#' MaxSize = 60
#' SizeInt = 1
#' SampSize = 1000
#' Cohorts=1
#' Shape1 = 20
#' Rate1 = 1
#' ObsSize = round(rgamma(SampSize, Shape1, Rate1),0)
#' HistData=hist(ObsSize, breaks=seq(0,MaxSize,SizeInt), right=FALSE, plot=FALSE)
#' ObsFreq = HistData$counts
#' DistnType = 2 # 1=normal, 2=gamma
#' params = log(c(20, 1)) # gamma
#' res=GetMixtureModelResults(params, DistnType, Cohorts, MinSize, MaxSize, SizeInt, ObsFreq)
#' # Get mean and mode of fitted gamma distribution
#' alpha = res$ParamEst[1,1]
#' beta = 1 / res$ParamEst[2,1]
#' # Simulate data with 2 modes, specifying normal distribution
#' set.seed(123)
#' MinSize = 0
#' MaxSize = 60
#' SizeInt = 1
#' SampSize = 1000
#' # normal
#' Mean1 = 20
#' Mean2 = 35
#' sd1 = 5
#' sd2 = 5
#' PropZero = 0.7
#' ObsSize1 = round(rnorm(PropZero*SampSize, Mean1, sd1),0)
#' ObsSize2 = round(rnorm((1-PropZero)*SampSize, Mean2, sd2),0)
#' ObsSize = c(ObsSize1,ObsSize2)
#' HistData=hist(ObsSize, breaks=seq(0,MaxSize,SizeInt), right=FALSE, plot=FALSE)
#' ObsFreq = HistData$counts
#' params = c(log(c(15, 40, 5, 5)), 0.5) # separate sd's for the 2 cohorts
#' Cohorts=2
#' DistnType = 1 # 1=normal, 2=gamma
#' GetMixtureModelResults(params, DistnType, Cohorts, MinSize, MaxSize, SizeInt, ObsFreq)
#' # Simulate data with 2 modes, specifying gamma distribution
#' set.seed(123)
#' MinSize = 0
#' MaxSize = 60
#' SizeInt = 1
#' SampSize = 1000
#' Shape1 = 20
#' Shape2 = 35
#' Rate1 = 1.5
#' Rate2 = 1
#' PropZero = 0.7
#' ObsSize1 = round(rgamma(PropZero*SampSize, Shape1, Rate1),0)
#' ObsSize2 = round(rgamma((1-PropZero)*SampSize, Shape2, Rate2),0)
#' ObsSize = c(ObsSize1,ObsSize2)
#' HistData=hist(ObsSize, breaks=seq(0,MaxSize,SizeInt), right=FALSE, plot=TRUE)
#' ObsFreq = HistData$counts
#' params = c(log(c(15, 40, 1, 1)), 0.5) # separate sd's for the 2 cohorts
#' Cohorts=2
#' DistnType = 2 # 1=normal, 2=gamma
#' res=GetMixtureModelResults(params, DistnType, Cohorts, MinSize, MaxSize, SizeInt, ObsFreq)
#' # Get means and modes of fitted gamma distributions
#' alpha = res$ParamEst[1,1]
#' beta = 1 / res$ParamEst[3,1]
#' Dist_mean1 = alpha * beta
#' Dist_mode1 = (alpha - 1) * beta
#' alpha = res$ParamEst[2,1]
#' beta = 1 / res$ParamEst[4,1]
#' Dist_mean2 = alpha * beta
#' Dist_mode2 = (alpha - 1) * beta
#' @export
GetMixtureModelResults <- function(params, DistnType, Cohorts, MinSize, MaxSize, SizeInt, ObsFreq) {

  if (length(which(c(2,4,5,8) == length(params))) == 0) {
    stop("Problem: not correct number of parameters")
  }

  # fit mixture model
  nlmb = FitMixtureDistnModel(params, DistnType, Cohorts, MinSize, MaxSize, SizeInt, ObsFreq)

  # extract information useful for plotting
  params = nlmb$par
  Res=EstPropAtLen_MixtureDistn(params)
  expfreq1 = Res$expfreq1
  expfreq2 = Res$expfreq2
  expfreq3 = Res$expfreq3
  ExpPropAtLen = Res$ExpPropAtLen
  ExpFreqAtLen = Res$ExpFreqAtLen

  # calculate uncertianty for parameter estimates by getting variance-covariance matrix,
  # from fitted model, to get standard errors
  (hess.out = optimHess(nlmb$par, CalcNLL_SizeMixtureDistn))
  (vcov.params = solve(hess.out))
  (ses = sqrt(diag(vcov.params))) # asymptotic standard errors of parameter estimates

  # back log-transform parameters
  if (length(params) == 2) { # 1 cohort
    if (DistnType == 1) { # normal
      EstMean1 = c(exp(nlmb$par[1]), exp(nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
      EstMean1_sd = ses[1]
      EstMean2_sd = NA
      EstMean3_sd = NA
      Estsd1 = c(exp(nlmb$par[2]), exp(nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
      ParamEst = t(data.frame(EstMean1=round(EstMean1,2), Estsd1=round(Estsd1,2)))
    }
    if (DistnType == 2) { # gamma
      EstShape1 = c(exp(nlmb$par[1]), exp(nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
      EstShape1_sd = ses[1]
      EstShape2_sd = NA
      EstShape3_sd = NA
      EstRate1 = c(exp(nlmb$par[2]), exp(nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
      ParamEst = t(data.frame(EstShape1=round(EstShape1,2), EstRate1=round(EstRate1,2)))
    }
  }
  if (length(params) == 4) { # 2 cohorts common sd
    if (DistnType == 1) { # normal
      EstMean1 = c(exp(nlmb$par[1]), exp(nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
      EstMean2 = c(exp(nlmb$par[2]), exp(nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
      EstMean1_sd = ses[1]
      EstMean2_sd = ses[2]
      EstMean3_sd = NA
      Estsd1 = c(exp(nlmb$par[3]), exp(nlmb$par[3] + c(-1.96, 1.96) * ses[3]))
      Estsd2 = c(exp(nlmb$par[3]), exp(nlmb$par[3] + c(-1.96, 1.96) * ses[3]))
      EstPropZero = ilogit(c(nlmb$par[4], nlmb$par[4] + c(-1.96, 1.96) * ses[4]))
      ParamEst = t(data.frame(EstMean1=round(EstMean1,2), EstMean2=round(EstMean2,2),
                              Estsd1=round(Estsd1,2), Estsd2=round(Estsd2,2),
                              EstPropZero=round(EstPropZero,2)))
      if (DistnType == 2) { # gamma
        EstShape1 = c(exp(nlmb$par[1]), exp(nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
        EstShape2 = c(exp(nlmb$par[2]), exp(nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
        EstShape1_sd = ses[1]
        EstShape2_sd = ses[2]
        EstShape3_sd = NA
        EstRate1 = c(exp(nlmb$par[3]), exp(nlmb$par[3] + c(-1.96, 1.96) * ses[3]))
        EstRate2 = c(exp(nlmb$par[3]), exp(nlmb$par[3] + c(-1.96, 1.96) * ses[3]))
        EstPropZero = ilogit(c(nlmb$par[4], nlmb$par[4] + c(-1.96, 1.96) * ses[4]))
        ParamEst = t(data.frame(EstShape1=round(EstShape1,2), EstShape2=round(EstShape2,2),
                                EstRate1=round(EstRate1,2), Estsd2=round(EstRate2,2),
                                EstPropZero=round(EstPropZero,2)))
      }
    }
  }
  if (length(params) == 5) { # 2 cohorts, separate sds
    if (DistnType == 1) { # normal
      EstMean1 = c(exp(nlmb$par[1]), exp(nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
      EstMean2 = c(exp(nlmb$par[2]), exp(nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
      EstMean1_sd = ses[1]
      EstMean2_sd = ses[2]
      EstMean3_sd = NA
      Estsd1 = c(exp(nlmb$par[3]), exp(nlmb$par[3] + c(-1.96, 1.96) * ses[3]))
      Estsd2 = c(exp(nlmb$par[4]), exp(nlmb$par[4] + c(-1.96, 1.96) * ses[4]))
      EstPropZero = ilogit(c(nlmb$par[5], nlmb$par[5] + c(-1.96, 1.96) * ses[5]))
      ParamEst = t(data.frame(EstMean1=round(EstMean1,2), EstMean2=round(EstMean2,2),
                              Estsd1=round(Estsd1,2), Estsd2=round(Estsd2,2),
                              EstPropZero=round(EstPropZero,2)))
    }
    if (DistnType == 2) { # gamma
      EstShape1 = c(exp(nlmb$par[1]), exp(nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
      EstShape2 = c(exp(nlmb$par[2]), exp(nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
      EstShape1_sd = ses[1]
      EstShape2_sd = ses[2]
      EstShape3_sd = NA
      EstRate1 = c(exp(nlmb$par[3]), exp(nlmb$par[3] + c(-1.96, 1.96) * ses[3]))
      EstRate2 = c(exp(nlmb$par[4]), exp(nlmb$par[4] + c(-1.96, 1.96) * ses[4]))
      EstPropZero = ilogit(c(nlmb$par[5], nlmb$par[5] + c(-1.96, 1.96) * ses[5]))
      ParamEst = t(data.frame(EstShape1=round(EstShape1,2), EstShape2=round(EstShape2,2),
                              EstRate1=round(EstRate1,2), EstRate2=round(EstRate2,2),
                              EstPropZero=round(EstPropZero,2)))
    }
  }
  if (length(params) == 8) { # 3 cohorts
    if (DistnType == 1) { # normal
      EstMean1 = c(exp(nlmb$par[1]), exp(nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
      EstMean2 = c(exp(nlmb$par[2]), exp(nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
      EstMean3 = c(exp(nlmb$par[3]), exp(nlmb$par[3] + c(-1.96, 1.96) * ses[3]))
      EstMean1_sd = ses[1]
      EstMean2_sd = ses[2]
      EstMean3_sd = ses[3]
      Estsd1 = c(exp(nlmb$par[4]), exp(nlmb$par[4] + c(-1.96, 1.96) * ses[4]))
      Estsd2 = c(exp(nlmb$par[5]), exp(nlmb$par[5] + c(-1.96, 1.96) * ses[5]))
      Estsd3 = c(exp(nlmb$par[6]), exp(nlmb$par[6] + c(-1.96, 1.96) * ses[6]))
      EstPropZero = ilogit(c(nlmb$par[7], nlmb$par[7] + c(-1.96, 1.96) * ses[7]))
      EstPropOne = ilogit(c(nlmb$par[8], nlmb$par[8] + c(-1.96, 1.96) * ses[8]))
      ParamEst = t(data.frame(EstMean1=round(EstMean1,2), EstMean2=round(EstMean2,2),EstMean3=round(EstMean3,2),
                              Estsd1=round(Estsd1,2), Estsd2=round(Estsd2,2),Estsd3=round(Estsd3,2),
                              EstPropZero=round(EstPropZero,2),EstPropOne=round(EstPropOne,2)))
    }
    if (DistnType == 2) { # gamma
      EstShape1 = c(exp(nlmb$par[1]), exp(nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
      EstShape2 = c(exp(nlmb$par[2]), exp(nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
      EstShape3 = c(exp(nlmb$par[3]), exp(nlmb$par[3] + c(-1.96, 1.96) * ses[3]))
      EstShape1_sd = ses[1]
      EstShape2_sd = ses[2]
      EstShape3_sd = ses[3]
      EstRate1 = c(exp(nlmb$par[4]), exp(nlmb$par[4] + c(-1.96, 1.96) * ses[4]))
      EstRate2 = c(exp(nlmb$par[5]), exp(nlmb$par[5] + c(-1.96, 1.96) * ses[5]))
      EstRate3 = c(exp(nlmb$par[6]), exp(nlmb$par[6] + c(-1.96, 1.96) * ses[6]))
      EstPropZero = ilogit(c(nlmb$par[7], nlmb$par[7] + c(-1.96, 1.96) * ses[7]))
      EstPropOne = ilogit(c(nlmb$par[8], nlmb$par[8] + c(-1.96, 1.96) * ses[8]))
      ParamEst = t(data.frame(EstShape1=round(EstShape1,2), EstShape2=round(EstShape2,2),EstShape3=round(EstShape3,2),
                              EsttRate1=round(EsttRate1,2), EsttRate2=round(EsttRate2,2),EsttRate3=round(EsttRate3,2),
                              EstPropZero=round(EstPropZero,2),EstPropOne=round(EstPropOne,2)))
    }
  }

  if (DistnType == 1) { # normal
    EstShape1_sd = NA
    EstShape2_sd = NA
    EstShape3_sd = NA
  }
  if (DistnType == 2) { # gamma
    EstMean1_sd = NA
    EstMean2_sd = NA
    EstMean3_sd = NA
  }

  colnames(ParamEst) = c("Estimate","lw_95%CL","up_95%CL")

  # store sample size
  SampleSize = sum(ObsFreq)

  # store value of objective function
  nll = nlmb$objective

  # store convergence value
  convergence = nlmb$convergence

  # get confidence limits for size frequencies
  Res=GetConfidenceLimitsForMixtureDistnCurve(params, vcov.params, DistnType)

  # store all results as a list object
  results = list(nll = nll,
                 convergence = convergence,
                 SampleSize = SampleSize,
                 ParamEst = ParamEst,
                 EstMean1_sd = EstMean1_sd,
                 EstMean2_sd = EstMean2_sd,
                 EstMean3_sd = EstMean3_sd,
                 EstShape1_sd = EstShape1_sd,
                 EstShape2_sd = EstShape2_sd,
                 EstShape3_sd = EstShape3_sd,
                 params = nlmb$par,
                 vcov.params = vcov.params,
                 expfreq1 = expfreq1,
                 expfreq2 = expfreq2,
                 expfreq3 = expfreq3,
                 ExpPropAtLen = ExpPropAtLen,
                 ExpFreqAtLen = ExpFreqAtLen,
                 gamma_mean1 = Res$gamma_mean1,
                 gamma_mean2 = Res$gamma_mean2,
                 gamma_mean3 = Res$gamma_mean3,
                 gamma_mode1 = Res$gamma_mode1,
                 gamma_mode2 = Res$gamma_mode2,
                 gamma_mode3 = Res$gamma_mode3,
                 gamma_mean1_lw = Res$gamma_mean1_lw,
                 gamma_mean2_lw = Res$gamma_mean2_lw,
                 gamma_mean3_lw = Res$gamma_mean3_lw,
                 gamma_mode1_lw = Res$gamma_mode1_lw,
                 gamma_mode2_lw = Res$gamma_mode2_lw,
                 gamma_mode3_lw = Res$gamma_mode3_lw,
                 gamma_mean1_up = Res$gamma_mean1_up,
                 gamma_mean2_up = Res$gamma_mean2_up,
                 gamma_mean3_up = Res$gamma_mean3_up,
                 gamma_mode1_up = Res$gamma_mode1_up,
                 gamma_mode2_up = Res$gamma_mode2_up,
                 gamma_mode3_up = Res$gamma_mode3_up)

  return(results)

}

# get expected size frequency
MixtureDistnCurve_SizeFreq <- function(params) {

  Res=EstPropAtLen_MixtureDistn(params)
  results = Res$ExpFreqAtLen

  return(results)
}

GetConfidenceLimitsForMixtureDistnCurve <- function(params, vcov.params, DistnType) {

  if (length(which(c(2,4,5,8) == length(params))) == 0) {
    stop("Problem: not correct number of parameters")
  }

  # store estimated parameter distributions
  set.seed(123)
  sims = data.frame(MASS::mvrnorm(n = 500, params, vcov.params))
  # head(sims)

  # determine number of cohorts to be fitted, based on specified number of starting parameters
  if (length(params) == 2) { # Cohorts=1
    if (DistnType == 1) { # normal
      names(sims) = c("Mean1", "sd1")
    }
    if (DistnType == 2) { # gamma
      names(sims) = c("Shape1", "Rate1")
    }
  }
  if (length(params) == 5) { # Cohorts=2
    if (DistnType == 1) { # normal
      names(sims) = c("Mean1", "Mean2","sd1","sd2","PropZero")
    }
    if (DistnType == 2) { # gamma
      names(sims) = c("Shape1", "Shape2","Rate1","Rate2","PropZero")
    }
  }
  if (length(params) == 8) { # Cohorts=3
    if (DistnType == 1) { # normal
      names(sims) = c("Mean1", "Mean2","Mean3","sd1","sd2","sd3","PropZero","PropOne")
    }
    if (DistnType == 2) { # gamma
      names(sims) = c("Shape1", "Shape2","Shape3","Rate1","Rate2","Rate3","PropZero","PropOne")
    }
  }

  if (DistnType == 2) { # gamma
    gmean1 = rep(0,500)
    gmode1 = rep(0,500)
    gmean2 = rep(0,500)
    gmode2 = rep(0,500)
    gmean3 = rep(0,500)
    gmode3 = rep(0,500)
    for (i in 1:500) {
      if (length(params) == 2) { # Cohorts=1
        alpha1 = exp(sims[i,1])
        beta1 = 1 / exp(sims[i,2])
        gmean1[i] = alpha1 * beta1
        gmode1[i] = (alpha1 - 1) * beta1
      }
      if (length(params) == 5) { # Cohorts=2
        alpha1 = exp(sims[i,1])
        alpha2 = exp(sims[i,2])
        beta1 = 1 / exp(sims[i,3])
        beta2 = 1 / exp(sims[i,4])
        gmean1[i] = alpha1 * beta1
        gmode1[i] = (alpha1 - 1) * beta1
        gmean2[i] = alpha2 * beta2
        gmode2[i] = (alpha2 - 1) * beta2
      }
      if (length(params) == 8) { # Cohorts=3
        alpha1 = exp(sims[i,1])
        alpha2 = exp(sims[i,2])
        alpha3 = exp(sims[i,3])
        beta1 = 1 / exp(sims[i,4])
        beta2 = 1 / exp(sims[i,5])
        beta3 = 1 / exp(sims[i,6])
        gmean1[i] = alpha1 * beta1
        gmode1[i] = (alpha1 - 1) * beta1
        gmean2[i] = alpha2 * beta2
        gmode2[i] = (alpha2 - 1) * beta2
        gmean3[i] = alpha3 * beta3
        gmode3[i] = (alpha3 - 1) * beta3
      }
    }
  }

  if (DistnType == 1) { # normal
    gamma_mean1 = NA
    gamma_mode1 = NA
    gamma_mean2 = NA
    gamma_mode2 = NA
    gamma_mean3 = NA
    gamma_mode3 = NA
    gamma_mean1_lw = NA
    gamma_mode1_lw = NA
    gamma_mean2_lw = NA
    gamma_mode2_lw = NA
    gamma_mean3_lw = NA
    gamma_mode3_lw = NA
    gamma_mean1_up = NA
    gamma_mode1_up = NA
    gamma_mean2_up = NA
    gamma_mode2_up = NA
    gamma_mean3_up = NA
    gamma_mode3_up = NA

  }
  if (DistnType == 2) { # gamma
    if (length(params) == 2) { # Cohorts=1
      gamma_mean1 = median(gmean1)
      gamma_mode1 = median(gmode1)
      gamma_mean2 = NA
      gamma_mode2 = NA
      gamma_mean3 = NA
      gamma_mode3 = NA
      gamma_mean1_lw = gamma_mean1 - (1.96 * sqrt(sd(gmean1) / 500))
      gamma_mode1_lw = gamma_mode1 - (1.96 * sqrt(sd(gmode1) / 500))
      gamma_mean2_lw = NA
      gamma_mode2_lw = NA
      gamma_mean3_lw = NA
      gamma_mode3_lw = NA
      gamma_mean1_up = gamma_mean1 + (1.96 * sqrt(sd(gmean1) / 500))
      gamma_mode1_up = gamma_mode1 + (1.96 * sqrt(sd(gmode1) / 500))
      gamma_mean2_up = NA
      gamma_mode2_up = NA
      gamma_mean3_up = NA
      gamma_mode3_up = NA
    }
    if (length(params) == 5) { # Cohorts=2
      gamma_mean1 = median(gmean1)
      gamma_mode1 = median(gmode1)
      gamma_mean2 = median(gmean2)
      gamma_mode2 = median(gmode2)
      gamma_mean3 = NA
      gamma_mode3 = NA
      gamma_mean1_lw = gamma_mean1 - (1.96 * sqrt(sd(gmean1) / 500))
      gamma_mode1_lw = gamma_mode1 - (1.96 * sqrt(sd(gmode1) / 500))
      gamma_mean2_lw = gamma_mean2 - (1.96 * sqrt(sd(gmean2) / 500))
      gamma_mode2_lw = gamma_mode2 - (1.96 * sqrt(sd(gmode2) / 500))
      gamma_mean3_lw = NA
      gamma_mode3_lw = NA
      gamma_mean1_up = gamma_mean1 + (1.96 * sqrt(sd(gmean1) / 500))
      gamma_mode1_up = gamma_mode1 + (1.96 * sqrt(sd(gmode1) / 500))
      gamma_mean2_up = gamma_mean2 + (1.96 * sqrt(sd(gmean2) / 500))
      gamma_mode2_up = gamma_mode2 + (1.96 * sqrt(sd(gmode2) / 500))
      gamma_mean3_up = NA
      gamma_mode3_up = NA
    }
    if (length(params) == 8) { # Cohorts=3
      gamma_mean1 = median(gmean1)
      gamma_mode1 = median(gmode1)
      gamma_mean2 = median(gmean2)
      gamma_mode2 = median(gmode2)
      gamma_mean3 = median(gmean3)
      gamma_mode3 = median(gmode3)
      gamma_mean1_lw = gamma_mean1 - (1.96 * sqrt(sd(gmean1) / 500))
      gamma_mode1_lw = gamma_mode1 - (1.96 * sqrt(sd(gmode1) / 500))
      gamma_mean2_lw = gamma_mean2 - (1.96 * sqrt(sd(gmean2) / 500))
      gamma_mode2_lw = gamma_mode2 - (1.96 * sqrt(sd(gmode2) / 500))
      gamma_mean3_lw = gamma_mean3 - (1.96 * sqrt(sd(gmean3) / 500))
      gamma_mode3_lw = gamma_mode3 - (1.96 * sqrt(sd(gmode3) / 500))
      gamma_mean1_up = gamma_mean1 + (1.96 * sqrt(sd(gmean1) / 500))
      gamma_mode1_up = gamma_mode1 + (1.96 * sqrt(sd(gmode1) / 500))
      gamma_mean2_up = gamma_mean2 + (1.96 * sqrt(sd(gmean2) / 500))
      gamma_mode2_up = gamma_mode2 + (1.96 * sqrt(sd(gmode2) / 500))
      gamma_mean3_up = gamma_mean3 + (1.96 * sqrt(sd(gmean3) / 500))
      gamma_mode3_up = gamma_mode3 + (1.96 * sqrt(sd(gmode3) / 500))
    }
  }

  sims.size = apply(X=sims[,], MARGIN=1, FUN=MixtureDistnCurve_SizeFreq)

  # Calculating the 2.5th an 97.5th percentile
  sim.size.est = apply(sims.size, 1, function(x) quantile(x, 0.5))
  sim.size.low = apply(sims.size, 1, function(x) quantile(x, 0.025))
  sim.size.up = apply(sims.size, 1, function(x) quantile(x, 0.975))

  results = list(sim.size.est = sim.size.est,
                 sim.size.low = sim.size.low,
                 sim.size.up = sim.size.up,
                 gamma_mean1 = gamma_mean1,
                 gamma_mean2 = gamma_mean2,
                 gamma_mean3 = gamma_mean3,
                 gamma_mode1 = gamma_mode1,
                 gamma_mode2 = gamma_mode2,
                 gamma_mode3 = gamma_mode3,
                 gamma_mean1_lw = gamma_mean1_lw,
                 gamma_mean2_lw = gamma_mean2_lw,
                 gamma_mean3_lw = gamma_mean3_lw,
                 gamma_mode1_lw = gamma_mode1_lw,
                 gamma_mode2_lw = gamma_mode2_lw,
                 gamma_mode3_lw = gamma_mode3_lw,
                 gamma_mean1_up = gamma_mean1_up,
                 gamma_mean2_up = gamma_mean2_up,
                 gamma_mean3_up = gamma_mean3_up,
                 gamma_mode1_up = gamma_mode1_up,
                 gamma_mode2_up = gamma_mode2_up,
                 gamma_mode3_up = gamma_mode3_up)

  return(results)

}


# GetConfidenceLimitsForMixtureDistnCurve <- function(params, vcov.params, DistnType) {
#
#   if (length(which(c(2,4,5,8) == length(params))) == 0) {
#     stop("Problem: not correct number of parameters")
#   }
#
#   # store estimated parameter distributions
#   set.seed(123)
#   sims = data.frame(MASS::mvrnorm(n = 500, params, vcov.params))
#
#
#   # determine number of cohorts to be fitted, based on specified number of starting parameters
#   if (length(params) == 2) { # Cohorts=1
#     if (DistnType == 1) { # normal
#       names(sims) = c("Mean1", "sd1")
#     }
#     if (DistnType == 2) { # gamma
#       names(sims) = c("Shape1", "Rate1")
#     }
#   }
#   if (length(params) == 5) { # Cohorts=2
#     if (DistnType == 1) { # normal
#       names(sims) = c("Mean1", "Mean2","sd1","sd2","PropZero")
#     }
#     if (DistnType == 2) { # gamma
#       names(sims) = c("Shape1", "Shape2","Rate1","Rate2","PropZero")
#     }
#   }
#   if (length(params) == 8) { # Cohorts=3
#     if (DistnType == 1) { # normal
#       names(sims) = c("Mean1", "Mean2","Mean3","sd1","sd2","sd3","PropZero","PropOne")
#     }
#     if (DistnType == 2) { # gamma
#       names(sims) = c("Shape1", "Shape2","Shape3","Rate1","Rate2","Rate3","PropZero","PropOne")
#     }
#   }
#
#   sims.size = apply(X=sims[,], MARGIN=1, FUN=MixtureDistnCurve_SizeFreq)
#
#   # Calculating the 2.5th an 97.5th percentile
#   sim.size.est = apply(sims.size, 1, function(x) quantile(x, 0.5))
#   sim.size.low = apply(sims.size, 1, function(x) quantile(x, 0.025))
#   sim.size.up = apply(sims.size, 1, function(x) quantile(x, 0.975))
#
#   alpha = res$ParamEst[1,1]
#   beta = 1 / res$ParamEst[3,1]
#   gamma_mean1 = alpha * beta
#   gamma_mode1 = (alpha - 1) * beta
#
#
#   if (DistnType == 2) { # gamma
#
#     if (length(params) == 2) { # Cohorts=1
#
#     }
#
#   }
#
#   results = list(sim.size.est = sim.size.est,
#                  sim.size.low = sim.size.low,
#                  sim.size.up = sim.size.up)
#
#   return(results)
#
# }

#' Plot fitted mixture model to size frequency data.
#'
#' @param params  ObsFreq (NumericVector), PlotHist (Logical), MaxSize, SizeInt, (Numbers),
#' params, (NumericVector), ymax, xmax, yint, xint (Numbers), GraphTitle, xaxis_lab,
#' yaxis_lab (Strings), PlotCLs (Logical)
#' @return fitted mixture distribution curves either scatter plot or histogram
#' @examples
#' Simulate data with 1 mode, specifying normal distribution
#' set.seed(123)
#' MinSize = 0
#' MaxSize = 60
#' SizeInt = 1
#' SampSize = 1000
#' Cohorts=1
#' Mean1 = 20
#' sd1 = 5
#' ObsSize = round(rnorm(SampSize, Mean1, sd1),0)
#' HistData=hist(ObsSize, breaks=seq(0,MaxSize,SizeInt), right=FALSE, plot=FALSE)
#' ObsFreq = HistData$counts
#' # Specify starting parameter values for Mean1 and sd1, and return associated negative log-likelihood
#' DistnType = 1 # 1=normal, 2=gamma
#' params = log(c(30, 5)) # normal
#' PlotMixtureDistnResults(params, DistnType, Cohorts, ObsFreq, MinSize, MaxSize, SizeInt, ymax=100, xmax=50, yint=20, xint=10,
#' GraphTitle=NA, xaxis_lab=NA, yaxis_lab=NA, set.plot.par=TRUE, PlotHist=TRUE, PlotCLs=FALSE)
#' # Simulate data with 1 mode, specifying gamma distribution
#' set.seed(123)
#' MinSize = 0
#' MaxSize = 60
#' SizeInt = 1
#' SampSize = 1000
#' Cohorts=1
#' Shape1 = 20
#' Rate1 = 1
#' ObsSize = round(rgamma(SampSize, Shape1, Rate1),0)
#' HistData=hist(ObsSize, breaks=seq(0,MaxSize,SizeInt), right=FALSE, plot=FALSE)
#' ObsFreq = HistData$counts
#' DistnType = 2 # 1=normal, 2=gamma
#' params = log(c(20, 1)) # gamma
#' PlotMixtureDistnResults(params, DistnType, Cohorts, ObsFreq, MinSize, MaxSize, SizeInt, ymax=100, xmax=50, yint=20, xint=10,
#' GraphTitle=NA, xaxis_lab=NA, yaxis_lab=NA, set.plot.par=TRUE, PlotHist=TRUE, PlotCLs=FALSE)
#' # Simulate data with 2 modes, specifying normal distribution
#' set.seed(123)
#' MinSize = 0
#' MaxSize = 60
#' SizeInt = 1
#' SampSize = 1000
#' # normal
#' Mean1 = 20
#' Mean2 = 35
#' sd1 = 5
#' sd2 = 5
#' PropZero = 0.7
#' ObsSize1 = round(rnorm(PropZero*SampSize, Mean1, sd1),0)
#' ObsSize2 = round(rnorm((1-PropZero)*SampSize, Mean2, sd2),0)
#' ObsSize = c(ObsSize1,ObsSize2)
#' HistData=hist(ObsSize, breaks=seq(0,MaxSize,SizeInt), right=FALSE, plot=FALSE)
#' ObsFreq = HistData$counts
#' params = c(log(c(15, 40, 5, 5)), 0.5) # separate sd's for the 2 cohorts
#' Cohorts=2
#' DistnType = 1 # 1=normal, 2=gamma
#' PlotMixtureDistnResults(params, DistnType, Cohorts, ObsFreq, MinSize, MaxSize, SizeInt, ymax=100, xmax=50, yint=20, xint=10,
#' GraphTitle=NA, xaxis_lab=NA, yaxis_lab=NA, set.plot.par=TRUE, PlotHist=TRUE, PlotCLs=FALSE)
#' # Simulate data with 2 modes, specifying gamma distribution
#' set.seed(123)
#' MinSize = 0
#' MaxSize = 60
#' SizeInt = 1
#' SampSize = 1000
#' Shape1 = 20
#' Shape2 = 35
#' Rate1 = 1.5
#' Rate2 = 1
#' PropZero = 0.7
#' ObsSize1 = round(rgamma(PropZero*SampSize, Shape1, Rate1),0)
#' ObsSize2 = round(rgamma((1-PropZero)*SampSize, Shape2, Rate2),0)
#' ObsSize = c(ObsSize1,ObsSize2)
#' HistData=hist(ObsSize, breaks=seq(0,MaxSize,SizeInt), right=FALSE, plot=TRUE)
#' ObsFreq = HistData$counts
#' params = c(log(c(15, 40, 1, 1)), 0.5) # separate sd's for the 2 cohorts
#' Cohorts=2
#' DistnType = 2 # 1=normal, 2=gamma
#' PlotMixtureDistnResults(params, DistnType, Cohorts, ObsFreq, MinSize, MaxSize, SizeInt, ymax=100, xmax=50, yint=20, xint=10,
#' GraphTitle=NA, xaxis_lab=NA, yaxis_lab=NA, set.plot.par=TRUE, PlotHist=TRUE, PlotCLs=FALSE)
#' @export
PlotMixtureDistnResults <- function(params, DistnType, Cohorts, ObsFreq, MinSize, MaxSize, SizeInt, ymax=100, xmax=50, yint=20, xint=10,
                                    GraphTitle=NA, xaxis_lab=NA, yaxis_lab=NA, set.plot.par=TRUE, PlotHist=TRUE, PlotCLs=FALSE) {

  # get default axis limits and intervals
  xlims=Get_xaxis_scale(0:MaxSize)
  ylims=Get_yaxis_scale(ObsFreq)

  if (is.na(xmax)) {
    xmax = xlims$xmax
  }
  if (is.na(xint)) {
    xint = xlims$xint
  }

  if (is.na(ymax)) {
    ymax = ylims$ymax
  }
  if (is.na(yint)) {
    yint = ylims$yint
  }

  if (is.na(xaxis_lab)) {
    xaxis_lab = "Size, mm"
  }
  if (is.na(yaxis_lab)) {
    yaxis_lab = "Frequency"
  }

  if (set.plot.par == T) {
    par(mfrow=c(1,1), mar=c(5,4,2,2), oma=c(2,2,2,2), tck=0.02)
  }
  LbndSizeCl <- seq(0, MaxSize-SizeInt, SizeInt)
  MidPtSizeCl <- LbndSizeCl + (SizeInt/2)
  SizeIndivs=rep(LbndSizeCl,ObsFreq)

  # get parameter estimates
  Res=FitMixtureDistnModel(params, DistnType, Cohorts, MinSize, MaxSize, SizeInt, ObsFreq)
  params = Res$par
  Res=EstPropAtLen_MixtureDistn(params)

  if (PlotHist == FALSE) {
    plot(LbndSizeCl, ObsFreq, "p", xlim=c(0,xmax), ylim=c(0,ymax), cex=0.5, pch=16,
         frame=F, xaxt = 'n', yaxt = 'n', xlab="", ylab="", cex.main=0.8, main=GraphTitle)
  }

  if (PlotHist == TRUE) {
    HistData=hist(SizeIndivs, breaks=0:MaxSize, right=FALSE, plot=TRUE, col="light grey", border="black",
                  main=GraphTitle, cex.main=0.8, xaxt = 'n', yaxt = 'n', xlab="", ylab="", ylim=c(0,ymax))
    lines(MidPtSizeCl, Res$expfreq1, lwd=1)
  }

  if (!is.na(sum(Res$expfreq2))) {
    lines(MidPtSizeCl, Res$expfreq2, lwd=1)
  }
  if (!is.na(sum(Res$expfreq3))) {
    lines(MidPtSizeCl, Res$expfreq3, lwd=1)
  }

  axis(1, seq(0,xmax,xint),labels=NA, line=0.2)
  axis(2, seq(0,ymax,yint),labels=NA, line=0.2)
  axis(1, seq(0,xmax,xint), lwd=0, labels=seq(0,xmax,xint), line=-0.2)
  axis(2, seq(0,ymax,yint), lwd=0, labels=seq(0,ymax,yint), line=-0.2, las=1)
  mtext(xaxis_lab,las=1,side=1,line=3,cex=1.0)
  mtext(yaxis_lab,las=3,side=2,line=3,cex=1.0)
  if (length(params) == 2) Modes=1
  if (length(params) == 4) Modes=2 # common sd
  if (length(params) == 5) Modes=2 # separate sds
  if (length(params) == 8) Modes=3
  mtext(paste("Modes = ",Modes,sep=""), adj=0.1,side=3,las=1,line=-1,cex=0.6)


  if (PlotCLs == TRUE) {

    # fit mixture model and get results, including variance-covariance matrix
    Res=GetMixtureModelResults(params, DistnType, Cohorts, MinSize, MaxSize, SizeInt, ObsFreq)

    # get get parameter estimates and variance-covariance matrix
    params=Res$params
    vcov.params=Res$vcov.params

    # get confidence limits for size frequencies
    Res=GetConfidenceLimitsForMixtureDistnCurve(params, vcov.params, DistnType)

    # plot confidence limits

    if (PlotHist == TRUE) {
      x = c(MidPtSizeCl,rev(MidPtSizeCl)) # using shading for 95% CLs
      y = c(Res$sim.size.low, rev(Res$sim.size.up))
      polygon(x,y,col="light grey",border=NA)
      lines(MidPtSizeCl, Res$sim.size.est, "l", lty="solid")
      lines(MidPtSizeCl, Res$sim.size.low, "l", lty="dotted")
      lines(MidPtSizeCl, Res$sim.size.up, "l", lty="dotted")
    }
    if (PlotHist == FALSE) {
      x = c(LbndSizeCl,rev(LbndSizeCl)) # using shading for 95% CLs
      y = c(Res$sim.size.low, rev(Res$sim.size.up))
      polygon(x,y,col="light grey",border=NA)
      lines(LbndSizeCl, Res$sim.size.est, "l", lty="solid")
      lines(LbndSizeCl, Res$sim.size.low, "l", lty="dotted")
      lines(LbndSizeCl, Res$sim.size.up, "l", lty="dotted")
      points(LbndSizeCl, ObsFreq,cex=0.5, pch=16)
    }
  }
}


#****************************
# GROWTH - length-at-age data
#****************************

#' Simulates fish length at age data for individual fish, and mean length at age data
#'
#' @param number of samples, nSamples (Number), minimum age, MinAge (Number),
#' maximum age, MaxAge (Number), asymptotic length, Linf (Number), von Bertalanffy
#' growth coefficient, vbK (Number), hypothetical length at age zero, tzero (Number),
#' standard deviation of lengths at age, Growth_sd (Number)
#' @return simulated data including ages for individual fish, ObsAge (vector),
#' lengths for individual fish, ObsLen (Vector), age classes in sample (ObsAgeCl),
#' mean length for each age class, ObsMeanLen (vector), standard deviations for mean
#' lengths at age, ObsMeanLensd (vector), lower and upper 95% confidence limits for
#' mean lengths at age, ObsMeanLen_lw95CL, ObsMeanLen_hi95CL (vectors)
#' @examples
#' # Simulate fish length at age data, and mean length at age data from von
#' # Bertalanffy growth curve
#' set.seed(123)
#' nSamples = 300
#' MinAge = 1
#' MaxAge = 20
#' Linf = 300
#' vbK = 0.3
#' tzero = 0
#' Growth_sd = 0.1
#' Res = SimulateLengthAtAgeData_vonBert(nSamples, MinAge, MaxAge,
#'                                                   Linf, vbK, tzero, Growth_sd)
#' Res
#' # plot length at age data
#' ObsAge=Res$ObsAge
#' ObsLen=Res$ObsLen
#' plot(ObsAge, ObsLen)
#' # plot mean length at age data
#' ObsAgeCl=Res$ObsAgeCl
#' ObsMeanLen=Res$ObsMeanLen
#' ObsMeanLen_lw95CL=Res$ObsMeanLen_lw95CL
#' ObsMeanLen_hi95CL=Res$ObsMeanLen_hi95CL
#' ymax=1.1*max(Res$ObsMeanLen_hi95CL)
#' plot(ObsAgeCl, ObsMeanLen, ylim=c(0,ymax))
#' arrows(ObsAgeCl, ObsMeanLen_lw95CL, ObsAgeCl, ObsMeanLen_hi95CL,
#'        code=3, angle=90,length=0.02, col='black')
#' @export
SimulateLengthAtAgeData_vonBert <- function(nSamples, MinAge, MaxAge,
                                                        Linf, vbK, tzero, Growth_sd) {

  # observed length at age data
  ObsAge = runif(nSamples, MinAge, MaxAge)
  MeanLen = Linf * (1 - exp(-vbK * (ObsAge - tzero)))
  ObsLen = rnorm(nSamples, MeanLen, Growth_sd * MeanLen)

  # observed mean length and sd data
  Dat = data.frame(ObsAge=ObsAge,
                   ObsLen=ObsLen)
  Dat$AgeCl = trunc(ObsAge/1)*1
  MeanLenAtAge = aggregate(ObsLen ~ AgeCl, data=Dat, mean)
  ObsAgeCl = MeanLenAtAge[,1]
  ObsMeanLen = MeanLenAtAge[,2]
  Dat2 = aggregate(ObsLen ~ AgeCl, data=Dat, sd)
  ObsMeanLensd = Dat2[,2]

  ObsMeanLen_lw95CL = ObsMeanLen - (1.96 * ObsMeanLensd)
  ObsMeanLen_hi95CL = ObsMeanLen + (1.96 * ObsMeanLensd)

  Results = list(ObsAge=ObsAge,
                 ObsLen=ObsLen,
                 ObsAgeCl=ObsAgeCl,
                 ObsMeanLen=ObsMeanLen,
                 ObsMeanLensd=ObsMeanLensd,
                 ObsMeanLen_lw95CL=ObsMeanLen_lw95CL,
                 ObsMeanLen_hi95CL=ObsMeanLen_hi95CL)

  return(Results)

}


#' Calculate negative log-likelihood for a von Bertalanffy growth curve.
#'
#' Calculates the negative log-likelihood associated with a sample of fish length-at-age data
#' and associated von Bertalanffy growth curve parameter values
#' Function requires age and length data for individual fish (stored in memory in R).
#' ObsAge, ObsLen (Numeric Vectors)
#' This function (with parameter inputs) can be passed into R optimisation routines (e.g. nlminb).
#' @keywords internal
#' @param params For data type 1 (individual lengths at ages), Asymptotic length (Linf),
#' von Bertalanffy growth coefficient (vbK) and hypothetical age at zero length (tzero), Numbers.
#' For data type 2, require an additional parameter (Mod_sd).
#' @return Negative log-likelihood associated with growth curve fit to length-at-age data
CalcNLL_vonBertGrowthCurve <- function(params) {

  nObs = length(ObsAge)

  # calculate expected length at age growth, for von Bertalanffy growth curve
  ExpLen = CalcLengthAtAge_vonBertalanffyGrowthCurve(params)

  # calculate NLL for growth curve
  if (DataType==1) { # lengths at age for individual fish

    SqResid = ((ObsLen - ExpLen) ^ 2)
    sumSqResid = sum(SqResid)
    stdev = sqrt(sumSqResid / nObs)
    NLL = (nObs/2.) * (log(2 * pi) + 2 * log(stdev) + 1)
    Objfunc = NLL
  }
  if (DataType==2) { # lengths at age for individual fish

    # Mod_sd = exp(params[4])
    Objfunc = 0
    for (j in 1:nObs) {
      # NLL = (0.5 * log(Mod_sd^2 + ObsMeanLensd[j]^2)) + (0.5*log(2*pi)) +
      #   ((ObsMeanLen[j] - ExpLen[j])^2) / (2 * (Mod_sd^2 + ObsMeanLensd[j]^2))
      NLL = (0.5 * log(ObsMeanLensd[j]^2)) + (0.5*log(2*pi)) +
        ((ObsMeanLen[j] - ExpLen[j])^2) / (2 * (ObsMeanLensd[j]^2))

      Objfunc = Objfunc + NLL

    }
  }


  results = Objfunc

  return(results)

}

CalcLengthAtAge_vonBertalanffyGrowthCurve <- function(params) {

  # calculate expected length at age growth, for von Bertalanffy growth curve (ages of fish in sample)
  Linf = exp(params[1])
  vbK = exp(params[2])
  tzero = params[3]

  ExpLen = Linf * (1 - exp(-vbK * (ObsAge - tzero)))

  return(ExpLen)
}

CalcLengthAtAge_vonBertalanffyGrowthCurve2 <- function(params) {
  # for plotting - calculate expected length at age growth, for von Bertalanffy growth curve (specified age range)

  Linf = exp(params[1])
  vbK = exp(params[2])
  tzero = params[3]

  plotlengths = Linf * (1 - exp(-vbK * (plotages - tzero)))

  Result = list(plotages=plotages,
                plotlengths=plotlengths)

  return(Result)
}


#' Fit a von Bertalanffy growth curve to a sample of fish length-at-age data.
#'
#' This function fits a von Bertalanffy growth curve to a sample of fish length-at-age data
#' by minimising the negative log-likelihood associated with the parameters and data, using nlminb.
#' Function requires age and length data for individual fish (stored in memory in R).
#' ObsAge, ObsLen (Numeric Vectors)
#' @keywords internal
#' @param params Asymptotic length (Linf), von Bertalanffy growth coefficient (vbK) and
#'     hypothetical age at zero length (tzero), Numbers.
#' @return nlmb (stored output from internal R nlminb optimisation function)
FitvonBertalanffyGrowthModel <- function(params, DataType, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd) {

  nlmb <- nlminb(params, CalcNLL_vonBertGrowthCurve, gradient = NULL,
                 hessian = TRUE,  control=list(trace=1))

  results=nlmb
  return(results)
}

#' Get statistical outputs from a fitted von Bertalanffy growth curve.
#'
#' This function fits a von Bertalanffy growth curve to a sample of fish length-at-age data
#' by minimising the negative log-likelihood associated with the parameters and data,
#' using nlminb. It provides various statistical outputs in include convergence statistics,
#' parameter estimated and associated 95% confidence limits and associated variance-covariance matrix,
#' calculated using the MASS package.
#' Function requires age and length data for individual fish (stored in memory in R).
#' ObsAge, ObsLen (Numeric Vectors)
#' @param params Asymptotic length (Linf), von Bertalanffy growth coefficient (vbK) and
#'     hypothetical age at zero length (tzero), Numbers. Datatype (1=lengths at ages for
#'     individual fish, 2=mean length at age and sd) (Number), ObsAge (Vector)
#' @return negative log-likelihood (nll), nlminb convergence diagnostic (convergence)
#' sample size (SampleSize), growth parameter estimates with lower and upper 95%
#' confidence limits (ParamEst), point estimates for growth parameters (params)
#' and variance-covariance matrix (vcov.params)
#' @examples
#' # Simulate length at age data, and mean length at age data
#' nSamples = 300
#' MinAge = 1
#' MaxAge = 20
#' Linf = 300
#' vbK = 0.3
#' tzero = 0
#' Growth_sd = 0.1
#' Res = SimulateLengthAtAgeData_vonBert(nSamples, MinAge, MaxAge,
#'                                                   Linf, vbK, tzero, Growth_sd)
#' # plot length at age data
#' ObsAge=Res$ObsAge
#' ObsLen=Res$ObsLen
#' plot(ObsAge, ObsLen)
#' # fit von Bertalanffy growth curve to length at age data
#' DataType=1  # 1=lengths at age data for individual fish, 2=mean length at age and sd data from mixture analysis
#' params = c(log(300),log(0.3),0) # log(Linf), log(k), tzero
#' res=GetvonBertalanffyGrowthResults(params, DataType, ObsAge, ObsLen, ObsMeanLen=NA, ObsMeanLensd=NA)
#' # plot mean length at age data
#' ObsAgeCl=Res$ObsAgeCl
#' ObsMeanLen=Res$ObsMeanLen
#' ObsMeanLensd=Res$ObsMeanLensd
#' ObsMeanLen_lw95CL=Res$ObsMeanLen_lw95CL
#' ObsMeanLen_hi95CL=Res$ObsMeanLen_hi95CL
#' ymax=1.1*max(Res$ObsMeanLen_hi95CL)
#' plot(ObsAgeCl, ObsMeanLen, ylim=c(0,ymax))
#' arrows(ObsAgeCl, ObsMeanLen_lw95CL, ObsAgeCl, ObsMeanLen_hi95CL,
#'        code=3, angle=90,length=0.02, col='black')
#' # fit von Bertalanffy growth curve to mean length at age data
#' DataType=2 # 1=lengths at age data for individual fish, 2=mean length at age and sd data from mixture analysis
#' ObsAgeCl=Res$ObsAgeCl
#' ObsMeanLen=Res$ObsMeanLen
#' ObsMeanLensd=Res$ObsMeanLensd
#' ObsAge=ObsAgeCl
#' params = c(log(300),log(0.3),0) # log(Linf), log(k), tzero
#' GetvonBertalanffyGrowthResults(params, DataType, ObsAge, ObsLen=NA, ObsMeanLen, ObsMeanLensd)
#' @export
GetvonBertalanffyGrowthResults <- function(params, DataType, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd) {

  # fit growth model
  nlmb = FitvonBertalanffyGrowthModel(params, DataType, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd)

  # get estimates
  nlmb$objective # value of nll
  nlmb$convergence
  nlmb$par

  # calculate uncertainty for parameter estimates by getting variance-covariance matrix,
  # from fitted model, to get standard errors
  (hess.out = optimHess(nlmb$par, CalcNLL_vonBertGrowthCurve))
  (vcov.params = solve(hess.out))
  (ses = sqrt(diag(vcov.params))) # asymptotic standard errors of parameter estimates

  EstLinf = c(exp(nlmb$par[1]), exp(nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
  EstvbK = c(exp(nlmb$par[2]), exp(nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
  Esttzero <- c(nlmb$par[3], nlmb$par[3] + c(-1.96, 1.96) * ses[3])

  # store results in data frame
  ParamEst = t(data.frame(Linf=round(EstLinf,1), vbK=round(EstvbK,2), tzero=round(Esttzero,2)))
  colnames(ParamEst) = c("Estimate","lw_95%CL","up_95%CL")


  # store sample size
  SampleSize = length(ObsAge)

  # store value of objective function
  nll = nlmb$objective

  # store convergence value
  convergence = nlmb$convergence

  # store all results as a list object
  results = list(nll = nll,
                 convergence = convergence,
                 SampleSize = SampleSize,
                 ParamEst = ParamEst,
                 params = nlmb$par,
                 vcov.params = vcov.params)

  return(results)

}

#' Plot fish length-at-age data. Plots either raw data (set PlotCLs to FALSE) or
#' mean lengths at age with specified standard deviations for each mean length
#' (set PlotCLs to TRUE).
#'
#' @param GrowthEqn (Numbers), ObsAge, ObsLen, ObsMeanLensd (Numeric Vectors), ymax, xmax, yint, xint (Numbers),
#'      GraphTitle, xaxis_lab, yaxis_lab (Strings)
#' @return scatter plot of length-at-age data
#' @examples
#' # plot mean lengths at age with approx 95% CLs given sd at length
#'nSamples = 300
#'ObsAge = 1:20
#'MeanLen = 300 * (1 - exp(-0.3 * (ObsAge - 0)))
#'ObsLen = MeanLen
#'ObsMeanLensd = MeanLen*0.1
#'PlotLengthAtAgeData(ObsAge, ObsLen, ObsMeanLensd, ymax=NA, xmax=NA, yint=NA, xint=NA,
#'                    GraphTitle=NA, xaxis_lab=NA, yaxis_lab=NA, PlotCLs=TRUE)
#' # plot raw lengths at age
#'set.seed(123)
#'nSamples = 300
#'ObsAge = runif(nSamples, 1, 20)
#'MeanLen = 300 * (1 - exp(-0.3 * (ObsAge - 0)))
#'ObsLen = rnorm(nSamples, MeanLen, 0.1 * MeanLen)
#'PlotLengthAtAgeData(ObsAge, ObsLen, ObsMeanLensd=NA, ymax=NA, xmax=NA, yint=NA, xint=NA,
#'                    GraphTitle=NA, xaxis_lab=NA, yaxis_lab=NA, PlotCLs=TRUE)
#' @export
PlotLengthAtAgeData <- function(ObsAge, ObsLen, ObsMeanLensd, ymax, xmax,
                                yint, xint, GraphTitle, xaxis_lab, yaxis_lab, PlotCLs) {

  # get default axis limits and intervals
  xlims=Get_xaxis_scale(ObsAge)
  ylims=Get_yaxis_scale(ObsLen)

  if (is.na(xmax)) {
    xmax = xlims$xmax
  }
  if (is.na(xint)) {
    xint = xlims$xint
  }

  if (is.na(ymax)) {
    ymax = ylims$ymax
  }
  if (is.na(yint)) {
    yint = ylims$yint
  }

  if (is.na(xaxis_lab)) {
    xaxis_lab = "Age, yrs"
  }
  if (is.na(yaxis_lab)) {
    yaxis_lab = "Length, mm"
  }

  plot(ObsAge, ObsLen, "p", xlim=c(0,xmax), ylim=c(0,ymax), cex=0.5, pch=16,
       frame=F, xaxt = 'n', yaxt = 'n', xlab="", ylab="", main=GraphTitle)
  axis(1, seq(0,xmax,xint),labels=NA, line=0.2)
  axis(2, seq(0,ymax,yint),labels=NA, line=0.2)
  axis(1, seq(0,xmax,xint), lwd=0, labels=seq(0,xmax,xint), line=0)
  axis(2, seq(0,ymax,yint), lwd=0, labels=seq(0,ymax,yint), line=0, las=1)
  mtext(xaxis_lab,las=1,side=1,line=3,cex=1.0)
  mtext(yaxis_lab,las=3,side=2,line=3,cex=1.0)
  if (PlotCLs==TRUE) {
    ObsLenlw = ObsLen - (1.96 * ObsMeanLensd)
    ObsLenup = ObsLen + (1.96 * ObsMeanLensd)
    arrows(ObsAge, ObsLenlw, ObsAge, ObsLenup,
           code=3, angle=90,length=0.02, col='black')
  }
}

#' Use resampling to get confidence limits for the fitted growth curve.
#'
#' @param GrowthEqn (Numbers), params (Vector), vcov.params (Matrix), ObsAge (Vector)
#' @return scatter plot of length-at-age data
#' @export
GetConfidenceLimitsForGrowthCurve <- function(GrowthEqn, params, vcov.params, plotages) {

  # store estimated parameter distributions
  set.seed(123)

  sims = data.frame(MASS::mvrnorm(n = 500, params, vcov.params))

  if (GrowthEqn == 1) { # von Bertalanffy
    GetEstLen <- function(params) {
      res=CalcLengthAtAge_vonBertalanffyGrowthCurve2(params)
      res$plotlengths
      return(res$plotlengths)
    }
    names(sims) = c("Linf", "vbK","tzero")
    sims.growth = apply(X=sims[,], MARGIN=1, FUN=GetEstLen)
  }
  if (GrowthEqn == 2) { # Schnute
    GetEstLen <- function(params) {
      res=CalcLengthAtAge_SchnuteGrowthCurve2(params, t1, t2)
      res$plotlengths
      return(res$plotlengths)
    }
    names(sims) = c("y1", "y2","a","b")
    sims.growth = apply(X=sims[,], MARGIN=1, FUN=GetEstLen)
  }
  if (GrowthEqn == 3) { # Somers seasonal growth curve
    GetEstLen <- function(params) {
      res=CalcLengthAtAge_SomersSeasonalGrowthCurve2(params)
      res$plotlengths
      return(res$plotlengths)
    }
    names(sims) = c("Linf", "vbK","tzero","tc","C")
    sims.growth = apply(X=sims[,], MARGIN=1, FUN=GetEstLen)
  }


  # Calculating the 2.5th an 97.5th percentile
  sim.growth.est = apply(sims.growth, 1, function(x) quantile(x, 0.5))
  sim.growth.low = apply(sims.growth, 1, function(x) quantile(x, 0.025))
  sim.growth.up = apply(sims.growth, 1, function(x) quantile(x, 0.975))

  results = list(sim.growth.est = sim.growth.est,
                 sim.growth.low = sim.growth.low,
                 sim.growth.up = sim.growth.up,
                 sim.growth.xvals = plotages,
                 sims.params = sims,
                 sims.curves = sims.growth)

  return(results)

}

#' Plot fitted growth curve to fish length-at-age data.
#'
#' @param params  GrowthEqn (Number), ObsAge, ObsLen (NumericVectors), ymax, xmax, yint, xint (Numbers),
#'      GraphTitle, xaxis_lab, yaxis_lab (Strings), PlotCLs (Logical)
#' @return fitted curve on scatter plot with length-at-age data
#' @examples
#' # Generate length at age data for individual fish,
#' # fit von Bertalanffy growth curve and plot
#' set.seed(123)
#' nSamples = 300
#' MinAge = 1
#' MaxAge = 20
#' Linf = 300
#' vbK = 0.3
#' tzero = 0
#' Growth_sd = 0.1
#' Res = SimulateLengthAtAgeData_vonBert(nSamples, MinAge, MaxAge,
#'                                       Linf, vbK, tzero, Growth_sd)
#' ObsAge=Res$ObsAge
#' ObsLen=Res$ObsLen
#' plotages=seq(0, MaxAge,0.1)
#' DataType=1  # 1=lengths at age data for individual fish, 2=mean length at age and sd data from mixture analysis
#' params = c(log(300),log(0.3),0) # log(Linf), log(k), tzero
#' PlotFittedGrowthCurve(DataType=1,  GrowthEqn=1, ObsAge, ObsLen, ObsMeanLen=NA, ObsMeanLensd=NA,
#'                       params, plotages, ymax=400, xmax=NA, yint=50, xint=NA, GraphTitle=NA,
#'                       xaxis_lab=NA, yaxis_lab=NA, PlotCLs=T)
#' DataType=2
#' params = c(log(300),log(0.3),0) # log(Linf), log(k), tzero
#' ObsAge=Res$ObsAgeCl
#' ObsMeanLen=Res$ObsMeanLen
#' ObsMeanLensd=Res$ObsMeanLensd
#' plotages=seq(0, MaxAge,0.1)
#' PlotFittedGrowthCurve(DataType,  GrowthEqn=1, ObsAge, ObsLen=NA, ObsMeanLen, ObsMeanLensd,
#'                       params, plotages, ymax=400, xmax=NA, yint=50, xint=NA, GraphTitle=NA,
#'                       xaxis_lab=NA, yaxis_lab=NA, PlotCLs=T)
#' # Generate length at age data for individual fish,
#' # fit Schnute growth curve and plot
#' set.seed(123)
#' nSamples = 500
#' MinAge = 0.2
#' MaxAge = 20
#' ObsAge = runif(nSamples, MinAge, MaxAge)
#' t1=0.2; t2=10 # reference ages
#' y1=50; y2=400; a=0.1; b=2
#' Growth_cv = 0.1
#' Res=SimulateLengthAtAgeData_Schnute(nSamples, ObsAge,
#'                                     t1, t2, y1, y2, a, b, Growth_cv)
#' DataType=1  # 1=lengths at age data for individual fish, 2=mean length at age and sd data from mixture analysis
#' params = c(log(y1),log(y2),a,b)
#' ObsAge=Res$ObsAge
#' ObsLen=Res$ObsLen
#' plotages=seq(0, MaxAge,0.1)
#' PlotFittedGrowthCurve(DataType=1,  GrowthEqn=2, ObsAge, ObsLen, ObsMeanLen=NA, ObsMeanLensd=NA,
#'                       params, plotages, ymax=600, xmax=NA, yint=100, xint=NA, GraphTitle=NA,
#'                       xaxis_lab=NA, yaxis_lab=NA, PlotCLs=T)
#' DataType=2  # 1=lengths at age data for individual fish, 2=mean length at age and sd data from mixture analysis
#' y1=10; y2=95; a=0.2; b=2.5; #sd=0.5
#' params = c(log(y1),log(y2),a,b)
#' ObsAge=Res$ObsAgeCl
#' ObsMeanLen=Res$ObsMeanLen
#' ObsMeanLensd=Res$ObsMeanLensd
#' plotages=seq(0, MaxAge,0.1)
#' PlotFittedGrowthCurve(DataType=2,  GrowthEqn=2, ObsAge, ObsLen=NA, ObsMeanLen, ObsMeanLensd,
#'                       params, plotages, ymax=600, xmax=NA, yint=100, xint=NA, GraphTitle=NA,
#'                       xaxis_lab=NA, yaxis_lab=NA, PlotCLs=T)
#' # Generate length at age data for individual fish,
#' # fit Somers seasonal growth curve and plot
#' nSamples = 500
#' TimeStep = 1/12
#' MinAge = 2 * TimeStep
#' MaxAge = 3
#' Linf = 150
#' vbK = 1
#' tzero = 0
#' tc = 0.25
#' C = 0.8
#' Growth_cv = 0.1
#' set.seed(123)
#' ObsAge = runif(nSamples, 0.1, 3)
#' Res=SimulateLengthAtAgeData_SomersSeasonal(nSamples, TimeStep, ObsAge,
#'                                            Linf, vbK, tzero, tc, C, Growth_cv)
#' DataType = 1 # 1=lengths at age data for individual fish, 2=mean length at age and sd data from mixture analysis
#' ObsAge=Res$ObsAge
#' ObsLen=Res$ObsLen
#' plotages=seq(0, MaxAge,0.1)
#' params = c(log(160),log(0.8),0,0.25,0.8) #Linf, vbK, tzero, tc, C
#' PlotFittedGrowthCurve(DataType=1,  GrowthEqn=3, ObsAge, ObsLen, ObsMeanLen=NA, ObsMeanLensd=NA,
#'                       params, plotages, ymax=200, xmax=NA, yint=50, xint=NA, GraphTitle=NA,
#'                       xaxis_lab=NA, yaxis_lab=NA, PlotCLs=T)
#' DataType = 2 # 1=lengths at age data for individual fish, 2=mean length at age and sd data from mixture analysis
#' ObsAge=Res$ObsAgeCl
#' ObsMeanLen=Res$ObsMeanLen
#' ObsMeanLensd=Res$ObsMeanLensd
#' plotages=seq(0, MaxAge,0.1)
#' params = c(log(160),log(0.8),0,0.25,0.8) #Linf, vbK, tzero, tc, C
#' PlotFittedGrowthCurve(DataType=2,  GrowthEqn=3, ObsAge, ObsLen=NA, ObsMeanLen, ObsMeanLensd,
#'                       params, plotages=seq(0, MaxAge,0.1), ymax=200, xmax=NA, yint=20, xint=NA, GraphTitle=NA,
#'                       xaxis_lab=NA, yaxis_lab=NA, PlotCLs=T)
#' @export
PlotFittedGrowthCurve <- function(DataType, GrowthEqn, ObsAge, ObsLen, ObsMeanLen,
                                  ObsMeanLensd, params, plotages, ymax, xmax, yint, xint,
                                  GraphTitle, xaxis_lab, yaxis_lab, PlotCLs) {


  # get default axis limits and intervals
  xlims=Get_xaxis_scale(ObsAge)
  ylims=Get_yaxis_scale(ObsLen)

  if (is.na(xmax)) {
    xmax = xlims$xmax
  }
  if (is.na(xint)) {
    xint = xlims$xint
  }

  if (is.na(ymax)) {
    ymax = ylims$ymax
  }
  if (is.na(yint)) {
    yint = ylims$yint
  }

  if (is.na(xaxis_lab)) {
    xaxis_lab = "Age, yrs"
  }
  if (is.na(yaxis_lab)) {
    yaxis_lab = "Length, mm"
  }

  # fit growth curve and get results, including variance-covariance matrix
  if (GrowthEqn == 1) { # von Bertalanffy
    Res=GetvonBertalanffyGrowthResults(params, DataType, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd)
  }
  if (GrowthEqn == 2) { # Schnute
    Res=GetSchnuteGrowthResults(params, DataType, t1, t2, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd)
  }
  if (GrowthEqn == 3) { # seasonal growth
    Res=GetSeasonalGrowthResults(params, DataType, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd)
  }

  if (DataType == 1) FishLen = ObsLen
  if (DataType == 2) FishLen = ObsMeanLen
  plot(ObsAge, FishLen, "p", xlim=c(0,xmax), ylim=c(0,ymax), cex=0.5, pch=16,
       frame=F, xaxt = 'n', yaxt = 'n', xlab="", ylab="", main=GraphTitle)

  axis(1, seq(0,xmax,xint),labels=NA, line=0.2)
  axis(2, seq(0,ymax,yint),labels=NA, line=0.2)
  axis(1, seq(0,xmax,xint), lwd=0, labels=seq(0,xmax,xint), line=-0.2)
  axis(2, seq(0,ymax,yint), lwd=0, labels=seq(0,ymax,yint), line=-0.2, las=1)
  mtext(xaxis_lab,las=1,side=1,line=3,cex=1.0)
  mtext(yaxis_lab,las=3,side=2,line=3,cex=1.0)


  params=Res$params
  if (GrowthEqn == 1) { # von Bertalanffy
    res = CalcLengthAtAge_vonBertalanffyGrowthCurve2(params)
  }
  if (GrowthEqn == 2) { # Schnute
    res = CalcLengthAtAge_SchnuteGrowthCurve2(params, t1, t2)
  }
  if (GrowthEqn == 3) { # Seasonal growth
    res = CalcLengthAtAge_SomersSeasonalGrowthCurve2(params)
  }
  lines(res$plotages, res$plotlengths, lwd=2)

  if (PlotCLs == TRUE) {

    # get get parameter estimates and variance-covariance matrix
    vcov.params = Res$vcov.params

    # get confidence limits for estimated lengths
    Res=GetConfidenceLimitsForGrowthCurve(GrowthEqn, params, vcov.params, plotages)

    # plot confidence limits
    lw = 0
    hi = max(res$plotages)
    x = c(res$plotages,rev(res$plotages)) # using shading for 95% CLs
    y = c(Res$sim.growth.low, rev(Res$sim.growth.up))
    polygon(x,y,col="light grey",border=NA)
    lines(res$plotages, Res$sim.growth.est, "l", lty="solid")
    lines(res$plotages, Res$sim.growth.low, "l", lty="dotted")
    lines(res$plotages, Res$sim.growth.up, "l", lty="dotted")
    points(ObsAge, FishLen, cex=0.5, pch=16)
  }

  if (DataType == 2) {
    ObsLenlw = ObsMeanLen - (1.96 * ObsMeanLensd)
    ObsLenup = ObsMeanLen + (1.96 * ObsMeanLensd)
    arrows(ObsAge, ObsLenlw, ObsAge, ObsLenup,
           code=3, angle=90,length=0.02, col='black')
  }
}

#' Simulates seasonal fish length at age data for individual fish, and mean length at age data
#'
#' @param number of samples, nSamples (Number), specified ages, ObsAge (Vector), asymptotic length, Linf (Number), von Bertalanffy
#' growth coefficient, vbK (Number), hypothetical length at age zero, tzero (Number),
#' parameter affecting time of year of maximum growth, tc (Number), paramter affecting
#' amplitude of seasonality, C (Number), standard deviation of lengths at age, Growth_cv (Number)
#' @return simulated data including ages for individual fish, ObsAge (vector),
#' lengths for individual fish, ObsLen (Vector), age classes in sample (ObsAgeCl),
#' mean length for each age class, ObsMeanLen (vector), standard deviations for mean
#' lengths at age, ObsMeanLensd (vector), lower and upper 95% confidence limits for
#' mean lengths at age, ObsMeanLen_lw95CL, ObsMeanLen_hi95CL (vectors)
#' @examples
#' # Simulate length at age data for individual fish and mean
#' # length at age data from growth curve
#' set.seed(123)
#' nSamples = 500
#' MinAge = 0.2
#' MaxAge = 20
#' ObsAge = runif(nSamples, MinAge, MaxAge)
#' t1=0.2; t2=10 # reference ages
#' y1=50; y2=400; a=0.1; b=2
#' Growth_cv = 0.1
#' Res=SimulateLengthAtAgeData_Schnute(nSamples, ObsAge,
#'                                     t1, t2, y1, y2, a, b, Growth_cv)
#' # plot length at age data
#' ObsAge=Res$ObsAge
#' ObsLen=Res$ObsLen
#' plot(ObsAge, ObsLen)
#' # plot mean length at age data
#' ObsAge=Res$ObsAgeCl
#' ObsMeanLen=Res$ObsMeanLen
#' ObsMeanLen_lw95CL=Res$ObsMeanLen_lw95CL
#' ObsMeanLen_hi95CL=Res$ObsMeanLen_hi95CL
#' ymax=1.1*max(ObsMeanLen_hi95CL)
#' plot(ObsAge, ObsMeanLen, ylim=c(0,ymax))
#' arrows(ObsAge, ObsMeanLen_lw95CL, ObsAge, ObsMeanLen_hi95CL,
#'        code=3, angle=90,length=0.02, col='black')
#' @export
SimulateLengthAtAgeData_Schnute <- function(nSamples, ObsAge,
                                            t1, t2, y1, y2, a, b, Growth_cv) {

  MeanLen <- rep(NA,length(ObsAge))
  for (i in 1:nSamples) {
    Age <- ObsAge[i]
    MeanLen[i] = SchnuteGrowthfunction(Age, t1, t2, y1, y2, a, b)
  }
  ObsLen = rnorm(nSamples, MeanLen, Growth_cv * MeanLen)

  # observed mean length and sd data
  Dat = data.frame(ObsAge=ObsAge,
                   ObsLen=ObsLen)

  Dat$AgeCl = trunc(Dat$ObsAge/1)*1

  MeanLenAtAge = aggregate(ObsLen ~ AgeCl, data=Dat, mean)
  ObsAgeCl = MeanLenAtAge[,1]
  ObsMeanLen = MeanLenAtAge[,2]
  Dat2 = aggregate(ObsLen ~ AgeCl, data=Dat, sd)
  ObsMeanLensd = Dat2[,2]

  ObsMeanLen_lw95CL = ObsMeanLen - (1.96 * ObsMeanLensd)
  ObsMeanLen_hi95CL = ObsMeanLen + (1.96 * ObsMeanLensd)

  Results = list(ObsAge=ObsAge,
                 ObsLen=ObsLen,
                 ObsAgeCl=ObsAgeCl,
                 ObsMeanLen=ObsMeanLen,
                 ObsMeanLensd=ObsMeanLensd,
                 ObsMeanLen_lw95CL=ObsMeanLen_lw95CL,
                 ObsMeanLen_hi95CL=ObsMeanLen_hi95CL)

}


#' Calculate estimated length for a fish with a specified age from Schnute growth curve, given
#' reference ages and params
#'
#' Function requires two reference ages, t1 and t2 (stored in memory in R).
#' @param  y1, y2 (lengths at ages t1 and t2) a, b (shape parameters). Numbers.
#' @return Estimated length at a specified age
#' @examples
#' t1=0.5; t2=10
#' y1=50; y2=250; a=0; b=3
#' Age=2
#' SchnuteGrowthfunction(Age, t1, t2, y1, y2, a, b)
#' @export
SchnuteGrowthfunction <- function (Age, t1, t2, y1, y2, a, b) {
  # Schnute's versatile growth model

  # Reference:
  #    Schnute, J. T. and Richards, L. J.  (1990).  A unified aproach to the
  #    analysis of fish growth, maturity and survivorship data.  Can. J.
  #    Fish. Aquat. Sci. 47: 24-40.

  # If the age lies below the theoretical age at which the length is zero,
  # the estimated length is assumed to be zero.

  # robustify routine, prevent y2 being less than y1
  if (y2 < y1+2) {
    y2 = y1+2
    # cat("SchnuteGrowthfunction: y1", y1,"y2",y2,'\n')
  }

  # ' Determine which equation is to be used
  if (a == 0) {
    if (b == 0) {
      # Eqn(18)
      y = y1 * exp(log(y2 / y1) * (Age - t1) / (t2 - t1))

      if (y < 0) {
        y = 0
      } # y < 0
    } else {          #(b == 0)
      # Eqn(17)
      # First, let's work out tzero
      #cat("Age", Age, "y1",y1,"y2",y2,"b",b,'\n')
      tzero = t1 - (y1 ^ b) * (t2 - t1) / (y2 ^ b - y1 ^ b)

      if (Age < tzero) {
        y = 0
      } else {
        v = (y1 ^ b + (y2 ^ b - y1 ^ b) * (Age - t1) / (t2 - t1))
        y = v ^ (1 / b)
      }
    }
  }# a == 0

  if (a != 0) {
    if (b == 0) {
      # Eqn(16)
      y = y1 * exp(log(y2 / y1) * (1 - exp(-a * (Age - t1))) / (1 - exp(-a * (t2 - t1))))
      if (y < 0) {
        y = 0 }
    } else {
      # Eqn(15)
      # First. let's work out tzero
      if (1 + (y1 ^ b) * (1 - exp(-a * (t2 - t1))) / (y2 ^ b - y1 ^ b) <= 0) {
        tzero = t1 - log(1E-4) / a
      } else {
        tzero = t1 - log(1 + (y1 ^ b) * (1 - exp(-a * (t2 - t1))) / (y2 ^ b - y1 ^ b)) / a
      }
      if (is.nan(tzero)) {
        cat("SchnuteGrowthfunction: Problem calculating tzero",'\n')
      }
      # cat("Age",Age, "tzero",tzero, '\n')
      if (Age < tzero) {
        y = 0
      } else {
        v = (y1 ^ b + (y2 ^ b - y1 ^ b)
             * (1 - exp(-a * (Age - t1))) / (1 - exp(-a * (t2 - t1))))
        y = v ^ (1 / b)
      } # else
    } # b == 0
  }  # a != 0

  return(y)
} # end function


CalcLengthAtAge_SchnuteGrowthCurve <- function(params, t1, t2, ObsAge) {

  # calculate expected length at age growth, for Schnute growth curve (ages of fish in sample)
  y1 = exp(params[1])
  y2 = exp(params[2])
  a = params[3]
  b = params[4]

  nObs <- length(ObsAge)

  ExpLen = rep(NA,nObs)
  for (i in 1:nObs) {
    Age <- ObsAge[i]
    ExpLen[i] = SchnuteGrowthfunction(Age, t1, t2, y1, y2, a, b)
    #cat("Age",Age,"MeanLen",MeanLen[i],'\n')
  }

  return(ExpLen)
}

CalcLengthAtAge_SchnuteGrowthCurve2 <- function(params, t1, t2) {
  # for plotting - calculate expected length at age growth, for Schnute growth curve (specified age range)
  y1 = exp(params[1])
  y2 = exp(params[2])
  a = params[3]
  b = params[4]

  nObs = length(plotages)
  plotlengths = rep(NA,nObs)
  for (i in 1:nObs) {
    Age <- plotages[i]
    plotlengths[i] = SchnuteGrowthfunction(Age, t1, t2, y1, y2, a, b)
    # cat("Age",Age,"MeanLen",MeanLen[i],'\n')
  }

  Result = list(plotages=plotages,
                plotlengths=plotlengths)

  return(Result)
}


#' Calculate negative log-likelihood for a Schnute growth curve.
#'
#' Calculates the negative log-likelihood associated with a sample of fish length-at-age data
#' and associated Schnute growth curve parameter values
#' Function requires age and length data for individual fish ObsAge, ObsLen (Numeric Vectors)
#' (stored in memory in R).
#' This function (with parameter inputs) can be passed into R optimisation routines (e.g. nlminb).
#' @keywords internal
#' @param  y1, y2 (lengths at ages t1 and t2) a, b (shape parameters). Numbers.
#' @return Negative-log likelihood associated with growth curve fit to length-at-age data
CalcNLL_SchnuteGrowthCurve <- function(params) {

  nObs = length(ObsAge)

  y1 = exp(params[1])
  y2 = exp(params[2])

  Penalty = 0
  if (y2 < y1+2) {
    Penalty = 10 * ((y1+2) - y2) ^ 2
    cat("params",params,"Penalty",Penalty,'\n')
  }

  # calculate expected length at age growth, for Schnute growth curve
  ExpLen = CalcLengthAtAge_SchnuteGrowthCurve(params, t1, t2, ObsAge)

  # calculate NLL for growth curve
  if (DataType==1) { # lengths at age for individual fish

    SqResid = ((ObsLen - ExpLen) ^ 2)
    sumSqResid = sum(SqResid)
    stdev = sqrt(sumSqResid / nObs)
    NLL = (nObs/2.) * (log(2 * pi) + 2 * log(stdev) + 1)
    Objfunc = NLL
  }
  if (DataType==2) { # lengths at age for individual fish

    # Mod_sd = exp(params[5])
    Objfunc = 0
    for (j in 1:nObs) {
      # allowing for process error
      # NLL = (0.5 * log(Mod_sd^2 + ObsMeanLensd[j]^2)) + (0.5*log(2*pi)) +
      #   ((ObsMeanLen[j] - ExpLen[j])^2) / (2 * (Mod_sd^2 + ObsMeanLensd[j]^2))

      # without process error (assuming this cannot always be estimated)
      NLL = (0.5 * log(ObsMeanLensd[j]^2)) + (0.5*log(2*pi)) +
        ((ObsMeanLen[j] - ExpLen[j])^2) / (2 * (ObsMeanLensd[j]^2))
      Objfunc = Objfunc + NLL

    }
  }

  results = Objfunc + Penalty

  return(results)

}


#' Fit a Schnute growth curve to a sample of fish length-at-age data.
#'
#' This function fits a Schnute growth curve to a sample of fish length-at-age data
#' by minimising the negative log-likelihood associated with the parameters and data, using nlminb.
#' Function requires age and length data for individual fish (stored in memory in R).
#' ObsAge, ObsLen (Numeric Vectors)
#' @keywords internal
#' @param y1, y2 (lengths at ages t1 and t2) a, b (shape parameters). Numbers.
#' @return nlmb (stored output from internal R nlminb optimisation function)
FitSchnuteGrowthModel <- function(params, DataType, t1, t2, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd) {

  nlmb <- nlminb(params, CalcNLL_SchnuteGrowthCurve, gradient = NULL,
                 hessian = TRUE,  control=list(trace=1))

  results=nlmb
  return(results)
}

#' Get statistical outputs from a fitted Schnute growth curve.
#'
#' This function fits a Schnute growth curve to a sample of fish length-at-age data
#' by minimising the negative log-likelihood associated with the parameters and data,
#' using nlminb. It provides various statistical outputs in include convergence statistics,
#' parameter estimated and associated 95% confidence limits and associated variance-covariance matrix,
#' calculated using the MASS package.
#' Function requires two reference ages and age and length data for individual fish (stored in memory in R).
#' t1, t2 (Numbers), ObsAge, ObsLen (Numeric Vectors)
#' @param params y1, y2 (lengths at ages t1 and t2) a, b (shape parameters). Numbers.
#' @return negative log-likelihood (nll)
#' nlminb convergence diagnostic (convergence)
#' sample size (SampleSize)
#' growth parameter estimates with lower and upper 95% confidence limits (ParamEst)
#' point estimates for growth parameters (params)
#' variance-covariance matrix (vcov.params)
#' @examples
#' # Simulate length at age data for individual fish and mean
#' # length at age data from growth curve
#' set.seed(123)
#' nSamples = 500
#' MinAge = 0.2
#' MaxAge = 20
#' ObsAge = runif(nSamples, MinAge, MaxAge)
#' t1=0.2; t2=10 # reference ages
#' y1=50; y2=400; a=0.1; b=2
#' Growth_cv = 0.1
#' Res=SimulateLengthAtAgeData_Schnute(nSamples, ObsAge,
#'                                     t1, t2, y1, y2, a, b, Growth_cv)
#' # Fit Schnute growth curve to length at age data
#' ObsAge=Res$ObsAge
#' ObsLen=Res$ObsLen
#' DataType=1  # 1=lengths at age data for individual fish, 2=mean length at age and sd data from mixture analysis
#' params = c(log(y1),log(y2),a,b)
#' ObsMeanLen=NA
#' ObsMeanLensd=NA
#' GetSchnuteGrowthResults(params, DataType, t1, t2, ObsAge, ObsLen, ObsMeanLen=NA, ObsMeanLensd=NA)
#' # Fit Schnute growth curve to mean length at age data
#' DataType=2  # 1=lengths at age data for individual fish, 2=mean length at age and sd data from mixture analysis
#' params = c(log(y1),log(y2),a,b)
#' ObsAge=Res$ObsAgeCl
#' ObsMeanLen=Res$ObsMeanLen
#' ObsMeanLensd=Res$ObsMeanLensd
#' GetSchnuteGrowthResults(params, DataType, t1, t2, ObsAge, ObsLen=NA, ObsMeanLen, ObsMeanLensd)
#' @export
GetSchnuteGrowthResults <- function(params, DataType, t1, t2, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd) {

  # fit growth model
  nlmb = FitSchnuteGrowthModel(params, DataType, t1, t2, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd)

  # get estimates
  nlmb$objective # value of nll
  nlmb$convergence
  nlmb$par

  # calculate uncertainty for parameter estimates by getting variance-covariance matrix,
  # from fitted model, to get standard errors
  (hess.out = optimHess(nlmb$par, CalcNLL_SchnuteGrowthCurve))
  (vcov.params = solve(hess.out))
  (ses = sqrt(diag(vcov.params))) # asymptotic standard errors of parameter estimates

  y1 = exp(c(nlmb$par[1], nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
  y2 = exp(c(nlmb$par[2], nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
  a <- c(nlmb$par[3], nlmb$par[3] + c(-1.96, 1.96) * ses[3])
  b <- c(nlmb$par[4], nlmb$par[4] + c(-1.96, 1.96) * ses[4])

  # store results in data frame
  if (DataType == 1) {
    ParamEst = t(data.frame(y1=round(y1,1), y2=round(y2,1), a=round(a,3), b=round(b,3)))
  }
  if (DataType == 2) {
    # Mod_sd <- exp(c(nlmb$par[5], nlmb$par[5] + c(-1.96, 1.96) * ses[5]))
    # ParamEst = t(data.frame(y1=round(y1,1), y2=round(y2,1), a=round(a,3), b=round(b,3),
    #                         Mod_sd=round(Mod_sd,3)))
    ParamEst = t(data.frame(y1=round(y1,1), y2=round(y2,1), a=round(a,3), b=round(b,3)))
  }

  colnames(ParamEst) = c("Estimate","lw_95%CL","up_95%CL")

  # store sample size
  SampleSize = length(ObsAge)

  # store value of objective function
  nll = nlmb$objective

  # store convergence value
  convergence = nlmb$convergence

  # store all results as a list object
  results = list(nll = nll,
                 convergence = convergence,
                 SampleSize = SampleSize,
                 ParamEst = ParamEst,
                 params = nlmb$par,
                 vcov.params = vcov.params)

  return(results)

}

#' Simulates seasonal fish length at age data for individual fish, and mean length at age data
#'
#' @param number of samples, nSamples (Number), minimum age, MinAge (Number),
#' maximum age, MaxAge (Number), asymptotic length, Linf (Number), von Bertalanffy
#' growth coefficient, vbK (Number), hypothetical length at age zero, tzero (Number),
#' parameter affecting time of year of maximum growth, tc (Number), paramter affecting
#' amplitude of seasonality, C (Number), standard deviation of lengths at age, Growth_sd (Number)
#' @return simulated data including ages for individual fish, ObsAge (vector),
#' lengths for individual fish, ObsLen (Vector), age classes in sample (ObsAgeCl),
#' mean length for each age class, ObsMeanLen (vector), standard deviations for mean
#' lengths at age, ObsMeanLensd (vector), lower and upper 95% confidence limits for
#' mean lengths at age, ObsMeanLen_lw95CL, ObsMeanLen_hi95CL (vectors)
#' @examples
#' # Simulate seasonal length at age data, and mean length at age data
#' nSamples = 500
#' TimeStep = 1/12
#' MinAge = 2 * TimeStep
#' MaxAge = 3
#' Linf = 150
#' vbK = 1
#' tzero = 0
#' tc = 0.25
#' C = 0.8
#' Growth_cv = 0.1
#' set.seed(123)
#' ObsAge = runif(nSamples, 0.1, 3)
#' Res=SimulateLengthAtAgeData_SomersSeasonal(nSamples, TimeStep, ObsAge,
#'                                            Linf, vbK, tzero, tc, C, Growth_cv)
#' # plot length at age data
#' ObsAge=Res$ObsAge
#' ObsLen=Res$ObsLen
#' plot(ObsAge, ObsLen)
#' # plot mean length at age data
#' ObsAgeCl=Res$ObsAgeCl
#' ObsMeanLen=Res$ObsMeanLen
#' ObsMeanLensd=Res$ObsMeanLensd
#' ObsMeanLen_lw95CL=Res$ObsMeanLen_lw95CL
#' ObsMeanLen_hi95CL=Res$ObsMeanLen_hi95CL
#' ymax=1.1*max(Res$ObsMeanLen_hi95CL)
#' plot(ObsAgeCl, ObsMeanLen, ylim=c(0,ymax))
#' arrows(ObsAgeCl, ObsMeanLen_lw95CL, ObsAgeCl, ObsMeanLen_hi95CL,
#'        code=3, angle=90,length=0.02, col='black')
#' @export
SimulateLengthAtAgeData_SomersSeasonal <- function(nSamples, TimeStep, ObsAge,
                                                   Linf, vbK, tzero, tc, C, Growth_cv) {


  # observed length at age data
  params = c(log(Linf),log(vbK),tzero,tc,C) #Linf, vbK, tzero, tc, C
  MeanLen = CalcLengthAtAge_SomersSeasonalGrowthCurve(params)
  ObsLen = rnorm(nSamples, MeanLen, Growth_cv*MeanLen)

  # observed mean length and sd data
  Dat = data.frame(ObsAge=ObsAge,
                   ObsLen=ObsLen)
  Dat$AgeCl = trunc(Dat$ObsAge/TimeStep)*TimeStep

  MeanLenAtAge = aggregate(ObsLen ~ AgeCl, data=Dat, mean)
  ObsAgeCl = MeanLenAtAge[,1]
  ObsMeanLen = MeanLenAtAge[,2]
  Dat2 = aggregate(ObsLen ~ AgeCl, data=Dat, sd)
  ObsMeanLensd = Dat2[,2]

  ObsMeanLen_lw95CL = ObsMeanLen - (1.96 * ObsMeanLensd)
  ObsMeanLen_hi95CL = ObsMeanLen + (1.96 * ObsMeanLensd)

  Results = list(ObsAge=ObsAge,
                 ObsLen=ObsLen,
                 ObsAgeCl=ObsAgeCl,
                 ObsMeanLen=ObsMeanLen,
                 ObsMeanLensd=ObsMeanLensd,
                 ObsMeanLen_lw95CL=ObsMeanLen_lw95CL,
                 ObsMeanLen_hi95CL=ObsMeanLen_hi95CL)

  return(Results)

}


#' Get expected lengths at age from a seasonal growth curve, given growth parameters and ages.
#'
#' Returns expected lengths at age from Somers (1988) seasonal growth curve, given parameter values
#' and ages. Requires specified ages ObsAge (Numeric Vector) (stored in memory in R).
#' @param Linf, vbK, tzero, tc, C, Mod_sd (Numbers).
#' @return Returns expected lengths at age from Somers (1988) seasonal growth curve
#' @examples
#' # Generate length at age data for individual fish
#' DataType = 1
#' set.seed(123)
#' nSamples = 300
#' ObsAge = runif(nSamples, 0.1, 3)
#' params = c(log(150),log(1),0,0.25,0.8) #Linf, vbK, tzero, tc, C
#' MeanLen = CalcLengthAtAge_SomersSeasonalGrowthCurve(params)
#' ObsLen = rnorm(nSamples, MeanLen, 0.1*MeanLen)
#' plot(ObsAge, ObsLen)
#' params = c(log(150),log(1),0,0.25,0.8) #Linf, vbK, tzero, tc, C
#' res=CalcLengthAtAge_SomersSeasonalGrowthCurve(params)
#' points(ObsAge, res)
#' # Generate monthly mean length (with error) data, from mixture analysis
#' DataType = 2
#' set.seed(123)
#' ObsAge = seq(0.2, 3, 1/12)
#' nAges=length(ObsAge)
#' params = c(log(150),log(1),0,0.25,0.8) #Linf, vbK, tzero, tc, C
#' ObsMeanLen = CalcLengthAtAge_SomersSeasonalGrowthCurve(params)
#' ObsMeanLensd = rnorm(nAges,5,1)
#' ObsLenlw = ObsMeanLen - (1.96 * ObsMeanLensd)
#' ObsLenup = ObsMeanLen + (1.96 * ObsMeanLensd)
#' ymax=1.1*max(ObsLenup)
#' plot(ObsAge, ObsMeanLen, ylim=c(0,ymax))
#' arrows(ObsAge, ObsLenlw, ObsAge, ObsLenup,
#'        code=3, angle=90,length=0.02, col='black')
#' params = c(log(150),log(1),0,0.25,0.8) #Linf, vbK, tzero, tc, C
#' res=CalcLengthAtAge_SomersSeasonalGrowthCurve(params)
#' lines(ObsAge,res)
#' @export
CalcLengthAtAge_SomersSeasonalGrowthCurve <- function(params) {

  Linf = exp(params[1])
  vbK = exp(params[2])
  tzero = params[3]
  tc = params[4]
  C = params[5]
  # cat("Linf",Linf,"vbK",vbK,"tzero",tzero,"tc",tc,"C",C,'\n')

  nObs = length(ObsAge)
  S_age_t = rep(NA, nObs)
  ExpLen = rep(NA, nObs)

  for (j in 1:nObs) {

    S_age_t[j] = sin(2 * pi * (ObsAge[j] - tc))
    S_tzero = sin(2 * pi * (tzero - tc))
    ExpLen[j] = Linf *(1 - exp(-vbK * (ObsAge[j] - tzero +
                                         (C / (2 * pi)) * (S_age_t[j] - S_tzero))))

    # cat("j",j,"ObsAge[j]",ObsAge[j],"ExpLen[j]",ExpLen[j],'\n')
  }
  return(ExpLen)
}



#' Calculate negative log-likelihood for a seasonal growth curve.
#'
#' Calculates the negative log-likelihood associated with a sample of fish length-at-age data
#' and associated Somers (1988) seasonal growth curve parameter values
#' Function requires age and length data for individual fish ObsAge, ObsLen (Numeric Vectors)
#' (stored in memory in R).
#' This function (with parameter inputs) can be passed into R optimisation routines (e.g. nlminb).
#' @keywords internal
#' @param  Linf, vbK, tzero, tc, C, Mod_sd (Numbers).
#' @return Negative-log likelihood associated with growth curve fit to length-at-age data
CalcNLL_SeasonalGrowthCurve <- function(params) {

  nObs = length(ObsAge)

  ExpLen = CalcLengthAtAge_SomersSeasonalGrowthCurve(params)

  # calculate NLL for growth curve
  if (DataType==1) { # lengths at age for individual fish

    SqResid = ((ObsLen - ExpLen) ^ 2)
    sumSqResid = sum(SqResid)
    stdev = sqrt(sumSqResid / nObs)
    NLL = (nObs/2.) * (log(2 * pi) + 2 * log(stdev) + 1)
    Objfunc = NLL
  }

  if (DataType==2) { # lengths at age for individual fish

    # Mod_sd = exp(params[6])
    Objfunc = 0
    for (j in 1:nObs) {
      # allowing for process error
      # NLL = (0.5 * log(Mod_sd^2 + ObsMeanLensd[j]^2)) + (0.5*log(2*pi)) +
      #   ((ObsMeanLen[j] - ExpLen[j])^2) / (2 * (Mod_sd^2 + ObsMeanLensd[j]^2))

      # without process error (assuming this cannot always be estimated)
      NLL = (0.5 * log(ObsMeanLensd[j]^2)) + (0.5*log(2*pi)) +
        ((ObsMeanLen[j] - ExpLen[j])^2) / (2 * (ObsMeanLensd[j]^2))
      Objfunc = Objfunc + NLL

    }
  }

  return(Objfunc)

}


#' Fit a seasonal growth curve to a sample of fish length-at-age data.
#'
#' This function fits a Somers (1988) growth curve to a sample of fish length-at-age data
#' by minimising the negative log-likelihood associated with the parameters and data, using nlminb.
#' Function requires age and length data for individual fish (stored in memory in R).
#' ObsAge, ObsLen (Numeric Vectors)
#' @keywords internal
#' @param Linf, vbK, tzero, tc, C, Mod_sd (Numbers).
#' @return nlmb (stored output from internal R nlminb optimisation function)
FitSeasonalGrowthModel <- function(params, DataType, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd) {

  nlmb <- nlminb(params, CalcNLL_SeasonalGrowthCurve, gradient = NULL,
                 hessian = TRUE,  control=list(trace=1))

  results=nlmb
  return(results)
}

#' Get statistical outputs from a fitted seasonal growth curve.
#'
#' This function fits Somers (1988) seasonal growth curve to a sample of fish length-at-age data
#' by minimising the negative log-likelihood associated with the parameters and data,
#' using nlminb. It provides various statistical outputs in include convergence statistics,
#' parameter estimated and associated 95% confidence limits and associated variance-covariance matrix,
#' calculated using the MASS package.
#' Function requires age and length data for individual fish (stored in memory in R).
#' ObsAge, ObsLen (Numeric Vectors)
#' @param params Linf, vbK, tzero, tc, C, Mod_sd (Numbers).
#' @return negative log-likelihood (nll)
#' nlminb convergence diagnostic (convergence)
#' sample size (SampleSize)
#' growth parameter estimates with lower and upper 95% confidence limits (ParamEst)
#' point estimates for growth parameters (params)
#' variance-covariance matrix (vcov.params)
#' @examples
#' # Simulate seasonal length at age data, and mean length at age data
#' nSamples = 500
#' TimeStep = 1/12
#' MinAge = 2 * TimeStep
#' MaxAge = 3
#' Linf = 150
#' vbK = 1
#' tzero = 0
#' tc = 0.25
#' C = 0.8
#' Growth_cv = 0.1
#' set.seed(123)
#' ObsAge = runif(nSamples, 0.1, 3)
#' Res=SimulateLengthAtAgeData_SomersSeasonal(nSamples, TimeStep, ObsAge,
#'                                            Linf, vbK, tzero, tc, C, Growth_cv)
#' # fit seasonal growth curve to length at age data
#' DataType = 1
#' ObsAge = Res$ObsAge
#' ObsLen = Res$ObsLen
#' ObsMeanLen = NA
#' ObsMeanLensd = NA
#' params = c(log(160),log(0.8),0,0.25,0.8) #Linf, vbK, tzero, tc, C
#' # fit seasonal growth curve to mean length at age data
#' GetSeasonalGrowthResults(params, DataType, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd)
#' DataType = 2
#' ObsLen = NA
#' ObsMeanLen = Res$ObsMeanLen
#' ObsMeanLensd = Res$ObsMeanLensd
#' ObsAge = seq(MinAge,MaxAge,TimeStep)
#' params = c(log(160),log(0.8),0,0.25,0.8) #Linf, vbK, tzero, tc, C
#' GetSeasonalGrowthResults(params, DataType, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd)
#' @export
GetSeasonalGrowthResults <- function(params, DataType, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd) {

  # fit growth model
  nlmb = FitSeasonalGrowthModel(params, DataType, ObsAge, ObsLen, ObsMeanLen, ObsMeanLensd)

  # get estimates
  nlmb$objective # value of nll
  nlmb$convergence
  nlmb$par

  # calculate uncertianty for parameter estimates by getting variance-covariance matrix,
  # from fitted model, to get standard errors
  (hess.out = optimHess(nlmb$par, CalcNLL_SeasonalGrowthCurve))
  (vcov.params = solve(hess.out))
  (ses = sqrt(diag(vcov.params))) # asymptotic standard errors of parameter estimates

  EstLinf = c(exp(nlmb$par[1]), exp(nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
  EstvbK = c(exp(nlmb$par[2]), exp(nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
  Esttzero <- c(nlmb$par[3], nlmb$par[3] + c(-1.96, 1.96) * ses[3])
  Esttc <- c(nlmb$par[4], nlmb$par[4] + c(-1.96, 1.96) * ses[4])
  EstC <- c(nlmb$par[5], nlmb$par[5] + c(-1.96, 1.96) * ses[5])

  # store results in data frame
  ParamEst = t(data.frame(Linf=round(EstLinf,1), vbK=round(EstvbK,2), tzero=round(Esttzero,2),
                          tc=round(Esttc,2), C=round(EstC,2)))
  colnames(ParamEst) = c("Estimate","lw_95%CL","up_95%CL")


  # store sample size
  SampleSize = length(ObsAge)

  # store value of objective function
  nll = nlmb$objective

  # store convergence value
  convergence = nlmb$convergence

  # store all results as a list object
  results = list(nll = nll,
                 convergence = convergence,
                 SampleSize = SampleSize,
                 ParamEst = ParamEst,
                 params = nlmb$par,
                 vcov.params = vcov.params)

  return(results)

}


CalcLengthAtAge_SomersSeasonalGrowthCurve2 <- function(params) {
  # for plotting - calculate expected length at age growth, for seasonal growth curve (specified age range)

  # define set of ages over range of data for ploting
  nObs = length(plotages)

  Linf = exp(params[1])
  vbK = exp(params[2])
  tzero = params[3]
  tc = params[4]
  C = params[5]
  # cat("Linf",Linf,"vbK",vbK,"tzero",tzero,"tc",tc,"C",C,'\n')

  S_age_t = rep(NA, nObs)
  plotlengths = rep(NA, nObs)
  for (j in 1:nObs) {

    S_age_t[j] = sin(2 * pi * (plotages[j] - tc))
    S_tzero = sin(2 * pi * (tzero - tc))
    plotlengths[j] = Linf *(1 - exp(-vbK * (plotages[j] - tzero +
                                              (C / (2 * pi)) * (S_age_t[j] - S_tzero))))
  }

  Result = list(plotages=plotages,
                plotlengths=plotlengths)

  return(Result)
}


#****************************
# GROWTH - tag-recapture data
#****************************


LenAtAge <- function(j, params, GrowthCrvChoice, CalculationStage, LenPrevIntAge, StartAge,
                     Obs_delta_t, Obs_Initlen, EstLenAtRelAge) {

  n = 1
  nstep = 50
  x = rep(0, n)

  # Initial time
  t = StartAge

  if (CalculationStage == 1) { # calculate final length, given time at liberty and initial length

    # Final time
    tAtEnd = Obs_delta_t[j]

    # Initial size
    x[1] = Obs_Initlen[j]
  }

  if (CalculationStage == 2) { # calculate annual growth increment, given initial length
    tAtEnd = 365

    # Initial size
    x[1] = j
  }

  if (CalculationStage == 3) { # (generating growth curve) calculate annual growth increment, given initial length
    tAtEnd = 365
    # Initial size
    x[1] = LenPrevIntAge
  }

  # Determine the value of x() at t = tAtEnd
  h = (tAtEnd - StartAge) / nstep

  x = RK4SYS(GrowthCrvChoice, h, t, x, params)

  EstLenAtRelAge[j] = x[1]

  return(EstLenAtRelAge[j])

}

RK4SYS <- function(GrowthCrvChoice, h, t, x, params)  {

  # Runge-Kutta 4'th order integration of
  # a system of n ordinary differential equations
  # of x() w.r. t, using a step size of h
  # over nstep steps.
  # number of derivatives - for runga kutta method of integration
  n = 1
  F1 = rep(0, n)
  F2 = rep(0, n)
  F3 = rep(0, n)
  F4 = rep(0, n)
  y = rep(0, n)

  h2 = 0.5 * h
  Start = t
  nstep = 50
  for (k in 1:nstep) {

    function_call = 1
    dxdt = derivs_x_wr_t(GrowthCrvChoice, function_call, x, y, params)
    F1[1] = dxdt

    for (i in 1:n) {
      y[i] = x[i] + h2 * F1[i]
    }

    function_call = 2
    dxdt = derivs_x_wr_t(GrowthCrvChoice, function_call, x, y, params)
    F2[1] = dxdt

    for (i in 1:n) {
      y[i] = x[i] + h2 * F2[i]
    }

    function_call = 3
    dxdt = derivs_x_wr_t(GrowthCrvChoice, function_call, x, y, params)
    F3[1] = dxdt

    for (i in 1:n) {
      y[i] = x[i] + h * F3[i]
    }

    function_call = 4
    dxdt = derivs_x_wr_t(GrowthCrvChoice, function_call, x, y, params)
    F4[1] = dxdt

    for (i in 1:n) {
      x[i] = x[i] + h * (F1[i] + 2. * (F2[i] + F3[i]) + F4[i]) / 6
    }
    t = Start + k * h
  }

  return(x)
}


derivs_x_wr_t <- function(GrowthCrvChoice, function_call, x, y, params) {
  # Calculate the derivatives of x w.r. t at
  # the current values of x, returning these as dxdt

  # In the abalone growth model, the variable x refers to
  # the size of the abalone, and t refers to the age of
  # the abalone (relative to some assumed age)
  if (function_call == 1) {
    InitialLength = x[1]
  }
  else {
    InitialLength = y[1]
  }

  # Calculate the terms that are used to produce the estimate of the derivative
  # of length
  if (GrowthCrvChoice == 1)   { # double logistic

    # L50_1, L95_1, L50_2, L95_2 (double logistic model)
    L50_1 = exp(params[1])
    L95_1 = exp(params[2])
    L50_2 = exp(params[3])
    L95_2 = exp(params[4])

    # Prop1 = 1 / (1 + exp(-log(19) * (InitialLength - L50_1) / (L95_1_used_in_model - L50_1)))
    # Prop2 = 1 / (1 + exp(log(19) * (InitialLength - L50_2) / (L95_2_used_in_model - L50_2)))
    Prop1 = 1 / (1 + exp(-log(19) * (InitialLength - L50_1) / (L95_1 - L50_1)))
    Prop2 = 1 / (1 + exp(log(19) * (InitialLength - L50_2) / (L95_2 - L50_2)))

    # Calculate the derivative
    dxdt = Max_increment * Prop1 * Prop2
  }

  if (GrowthCrvChoice == 2)   { # Gaussian function

    # Gaussian_A, Gaussian_u, Gaussian_sd (Gaussian function)
    Gaussian_A = exp(params[1])
    Gaussian_u = exp(params[2])
    Gaussian_sd = exp(params[3])

    dxdt = Gaussian_A * exp(-((InitialLength - Gaussian_u) *
                                (InitialLength - Gaussian_u)) / (2 * Gaussian_sd * Gaussian_sd))

    # cat("InitialLength",InitialLength,"dxdt",dxdt,"function_call",function_call,'\n')
  }

  if (GrowthCrvChoice == 3)   { # von Bertalanffy growth curve. delta_t is
    # converted t to decimal years (i.e., 1/52)

    # vb_Linf, vb_K (von Bertalanffy)
    vb_Linf = exp(params[1])
    vb_K = exp(params[2])
    dxdt = (vb_Linf - InitialLength) * (1 - exp(-vb_K * (1./365)))
  }

  if (GrowthCrvChoice == 4)   { # Gompertz growth curve. delta_t is
    # converted to decimal years (i.e., 1/52)

    # Gomp_Linf, Gomp_G
    Gomp_Linf = exp(params[1])
    Gomp_G = exp(params[2])
    dxdt = Gomp_Linf * pow((InitialLength / Gomp_Linf),exp(-Gomp_G * (1./365))) - InitialLength
  }

  return(dxdt)
}


#' Generate some tag-recapture data with varying times at liberty,
#' to which a growth curve may be fitted
#'
#' @param  Model 1: L50_1, L95_1, L50_2, L95_2 (double logistic model)
# ' Model 2: Gaussian_A, Gaussian_u, Gaussian_sd (Gaussian function)
#'  Model 3: vb_Linf, vb_K (von Bertalanffy)
#'  Model 4: Gomp_Linf, Gomp_G
#' @return tag-increment data
#' @examples
#' set.seed(123)
#' MaxLen = 240
#' MaxAge = 20
#' Gaussian_A = 0.1
#' Gaussian_u = 80
#' Gaussian_sd = 40
#' StandDev = 10
#' GrowthCrvChoice = 2 # 1 = double logistic, 2 = Gaussian function, 3 = von Bertalanffy growth curve, 4 = Gompertz growth curve
#' params = log(c(Gaussian_A, Gaussian_u, Gaussian_sd, StandDev))
#' nSamples = 200
#' CalculationStage = 1
#' res=SimulateTagRecaptureData(GrowthCrvChoice, nSamples, MaxLen, MaxAge, params)
#' plot(res$Obs_Initlen, res$Obs_Finlen, pch=16, cex=0.6)
#' lines(res$Initlen_line, res$Exp_Finlen2, col="blue")
#' lines(res$Initlen_line2, res$Exp_Finlen3, col="blue")
#' @return simulated tag-recapture data and expected final lengths with respect to specified initial
#' lengths, and expected (i.e. true) final lengths vs initial lengths used to simulate the data
#' with animals at two different times at liberty
#' @export
SimulateTagRecaptureData <- function(GrowthCrvChoice, nSamples, MaxLen, MaxAge, params) {

  EstLenAtRelAge = rep(0, nSamples)
  Exp_Finlen = rep(NA, nSamples)

  # generate random initial lengths
  rand_Initlen = round(runif(nSamples, 0.05*MaxLen, 0.95* MaxLen),0)
  # specify times at liberty
  rand_delta_t = c(rep(365, nSamples/2),rep(2*365, nSamples/2))

  StartAge = 0
  Obs_delta_t = rand_delta_t
  Obs_Initlen = rand_Initlen

  for (j in 1:nSamples) {
    Exp_Finlen[j] = LenAtAge(j, params, GrowthCrvChoice, CalculationStage, LenPrevIntAge=NA, StartAge,
                             Obs_delta_t, Obs_Initlen, EstLenAtRelAge)

  }

  Obs_Finlen = rnorm(length(Exp_Finlen),Exp_Finlen, StandDev)

  delta_t_line = rep(365,MaxLen)
  Initlen_line = 1:MaxLen
  Exp_Finlen2 = rep(NA,MaxLen)
  for (j in 1:MaxLen) {
    Exp_Finlen2[j] = LenAtAge(j, params, GrowthCrvChoice, CalculationStage, LenPrevIntAge=NA, StartAge,
                              delta_t_line, Initlen_line, EstLenAtRelAge)
  }

  delta_t_line2 = rep(2*365,MaxLen)
  Initlen_line2 = 1:MaxLen
  Exp_Finlen3 = rep(NA,MaxLen)
  for (j in 1:MaxLen) {
    Exp_Finlen3[j] = LenAtAge(j, params, GrowthCrvChoice, CalculationStage, LenPrevIntAge=NA, StartAge,
                              delta_t_line2, Initlen_line2, EstLenAtRelAge)
  }

  results = list(Obs_delta_t = Obs_delta_t,
                 Obs_Initlen = Obs_Initlen,
                 Obs_Finlen = Obs_Finlen,
                 delta_t_line = delta_t_line,
                 Initlen_line = Initlen_line,
                 Exp_Finlen2 = Exp_Finlen2,
                 delta_t_line2 = delta_t_line2,
                 Initlen_line2 = Initlen_line2,
                 Exp_Finlen3 = Exp_Finlen3)

  return(results)

}

#' Calculate negative log-likelihood for growth model fitted to tag-recapture data.
#'
#' Calculates the negative log-likelihood associated with a sample of animal tag-recapture data
#' and associated parameters of the growth model. Four alternative growth models are currently
#' available, i.e. von Bertalanffy curve, Gompertz curve, Gaussian function curve, Double logistic
#' function curve. Each describe the expected length increment between initial capture, measurement
#' and marking, and final capture and measurement.
#' Function requires data for individual animals on size at initial capture, size at final capture,
#' and time at liberty. Obs_Initlen, Obs_Finlen, Obs_delta_t (Numeric Vectors)
#' (stored in memory in R).
#' This function (with parameter inputs) can be passed into R optimisation routines (e.g. nlminb).
#' @keywords internal
#' @param  Model 1: L50_1, L95_1, L50_2, L95_2 (double logistic model)
# ' Model 2: Gaussian_A, Gaussian_u, Gaussian_sd (Gaussian function)
#'  Model 3: vb_Linf, vb_K (von Bertalanffy)
#'  Model 4: Gomp_Linf, Gomp_G
#' @return Negative-log likelihood associated with growth curve fit to tag-recapture data
CalcNLL_TaggingGrowthModel <- function(params) {
  # data not modified by removing negative growth increments
  StartAge = 0
  CalculationStage = 1
  StandDev = exp(params[4])
  EstLenAtRelAge = rep(0, nSamples)

  for (j in 1:nobs) {
    EstLenAtRelAge[j] = LenAtAge(j, params, GrowthCrvChoice, CalculationStage, LenPrevIntAge, StartAge,
                                 Obs_delta_t, Obs_Initlen, EstLenAtRelAge)
  }

  # estimated growth, given parameters, and length of time at liberty
  EstDeltaL = EstLenAtRelAge - Obs_Initlen

  NLL = -sum((dnorm(Obs_Finlen - Obs_Initlen, EstDeltaL, StandDev, log = TRUE)))

  return(NLL)
}


#' Fit a tagging growth model to tag-recapture data
#'
#' This function fits a tagging growth model to a sample of fish tag-recapture data
#' by minimising the negative log-likelihood associated with the parameters and data, using nlminb.
#' Function requires data for recorded times at liberty, initial and final lengths
#' of tagged and recaptured animals (stored in memory in R).
#' @keywords internal
#' Obs_delta_t, Obs_Initlen, Obs_Finlen (Numeric Vectors)
#' @param  Model 1: L50_1, L95_1, L50_2, L95_2 (double logistic model)
# ' Model 2: Gaussian_A, Gaussian_u, Gaussian_sd (Gaussian function)
#'  Model 3: vb_Linf, vb_K (von Bertalanffy)
#'  Model 4: Gomp_Linf, Gomp_G
#' @return nlmb (stored output from internal R nlminb optimisation function)
FitTaggingGrowthModel <- function(params, Obs_delta_t, Obs_Initlen, Obs_Finlen, nobs) {

  nlmb <- nlminb(params, CalcNLL_TaggingGrowthModel, gradient = NULL,
                 hessian = TRUE,  control=list(trace=1))

  results=nlmb
  return(results)
}


#' Get statistical outputs from a fitted tagging growth model.
#'
#' This function fits a model to fish tag-recapture data
#' by minimising the negative log-likelihood associated with the parameters and data,
#' using nlminb. It provides various statistical outputs in include convergence statistics,
#' parameter estimated and associated 95% confidence limits and associated variance-covariance matrix,
#' calculated using the MASS package.
#' Function requires data for recorded times at liberty, initial and final lengths
#' of tagged and recaptured animals (stored in memory in R).
#' Obs_delta_t, Obs_Initlen, Obs_Finlen (Numeric Vectors)
#' @param  Model 1: L50_1, L95_1, L50_2, L95_2 (double logistic model)
# ' Model 2: Gaussian_A, Gaussian_u, Gaussian_sd (Gaussian function)
#'  Model 3: vb_Linf, vb_K (von Bertalanffy)
#'  Model 4: Gomp_Linf, Gomp_G
#' @return negative log-likelihood (nll)
#' nlminb convergence diagnostic (convergence)
#' sample size (SampleSize)
#' growth parameter estimates with lower and upper 95% confidence limits (ParamEst)
#' point estimates for growth parameters (params)
#' variance-covariance matrix (vcov.params)
#' @examples
#' set.seed(123)
#' MaxLen = 240
#' MaxAge = 20
#' Gaussian_A = 0.1
#' Gaussian_u = 80
#' Gaussian_sd = 40
#' StandDev = 10
#' GrowthCrvChoice = 2 # 1 = double logistic, 2 = Gaussian function, 3 = von Bertalanffy growth curve, 4 = Gompertz growth curve
#' params = log(c(Gaussian_A, Gaussian_u, Gaussian_sd, StandDev))
#' nSamples = 200
#' CalculationStage = 1
#' res=SimulateTagRecaptureData(GrowthCrvChoice, nSamples, MaxLen, MaxAge, params)
#' Obs_delta_t=res$Obs_delta_t
#' Obs_Initlen=res$Obs_Initlen
#' Obs_Finlen=res$Obs_Finlen
#' nobs = nSamples
#' params = log(c(0.1, 80, 40, 10))
#' GetTaggingGrowthModelResults(params, Obs_delta_t, Obs_Initlen, Obs_Finlen, nobs)
#' @export
GetTaggingGrowthModelResults <- function(params, Obs_delta_t, Obs_Initlen, Obs_Finlen, nobs) {

  # fit maturity curve
  nlmb = FitTaggingGrowthModel(params, Obs_delta_t, Obs_Initlen, Obs_Finlen, nobs)

  # get estimates
  nlmb$objective # value of nll
  nlmb$convergence
  nlmb$par

  # get variance-covariance matrix, from fitted model, to get standard errors
  (hess.out = optimHess(params, CalcNLL_TaggingGrowthModel))
  (vcov.params = solve(hess.out))
  (ses = sqrt(diag(vcov.params))) # get asymptotic standard errors of parameter estimates


  # Calculate the terms that are used to produce the estimate of the derivative
  # of length
  if (GrowthCrvChoice == 1)   { # double logistic

    # L50_1, L95_1, L50_2, L95_2 (double logistic model)

    # calculate 95 percent confidence limits
    EstL50_1 = exp(c(nlmb$par[1], nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
    EstL95_1 =  exp(c(nlmb$par[2], nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
    EstL50_2 =  exp(c(nlmb$par[3], nlmb$par[3] + c(-1.96, 1.96) * ses[3]))
    EstL95_2 =  exp(c(nlmb$par[4], nlmb$par[4] + c(-1.96, 1.96) * ses[4]))
    EstStandDev =  exp(c(nlmb$par[5], nlmb$par[5] + c(-1.96, 1.96) * ses[5]))

    # store results in data frame
    ParamEst = t(data.frame(L50_1=round(EstL50_1,2), L95_1=round(EstL95_1,2),
                            L50_2=round(EstL50_2,2), L95_2=round(EstL95_2,2),
                            StandDev=round(EstStandDev,2)))
    colnames(ParamEst) = c("Estimate","lw_95%CL","up_95%CL")

  }

  if (GrowthCrvChoice == 2)   { # Gaussian function

    # Gaussian_A, Gaussian_u, Gaussian_sd (Gaussian function)

    EstGaussian_A =  exp(c(nlmb$par[1], nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
    EstGaussian_u =  exp(c(nlmb$par[2], nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
    EstGaussian_sd =  exp(c(nlmb$par[3], nlmb$par[3] + c(-1.96, 1.96) * ses[3]))
    EstStandDev =  exp(c(nlmb$par[4], nlmb$par[4] + c(-1.96, 1.96) * ses[4]))

    # store results in data frame
    ParamEst = t(data.frame(Gaussian_A=round(EstGaussian_A,2), Gaussian_u=round(EstGaussian_u,2),
                            Gaussian_sd=round(EstGaussian_sd,2),StandDev=round(EstStandDev,2)))
    colnames(ParamEst) = c("Estimate","lw_95%CL","up_95%CL")

  }

  if (GrowthCrvChoice == 3)   { # von Bertalanffy growth curve. delta_t is
    # converted t to decimal years (i.e., 1/52)

    # vb_Linf, vb_K (von Bertalanffy)
    Estvb_Linf =  exp(c(nlmb$par[1], nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
    Estvb_K =  exp(c(nlmb$par[2], nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
    EstStandDev =  exp(c(nlmb$par[3], nlmb$par[3] + c(-1.96, 1.96) * ses[3]))

    # store results in data frame
    ParamEst = t(data.frame(vb_Linf=round(Estvb_Linf,2), vb_K=round(Estvb_K,2),
                            StandDev=round(EstStandDev,2)))
    colnames(ParamEst) = c("Estimate","lw_95%CL","up_95%CL")

  }

  if (GrowthCrvChoice == 4)   { # Gompertz growth curve. delta_t is
    # converted to decimal years (i.e., 1/52)

    EstGomp_Linf =  exp(c(nlmb$par[1], nlmb$par[1] + c(-1.96, 1.96) * ses[1]))
    EstGomp_G =  exp(c(nlmb$par[2], nlmb$par[2] + c(-1.96, 1.96) * ses[2]))
    EstStandDev =  exp(c(nlmb$par[3], nlmb$par[3] + c(-1.96, 1.96) * ses[3]))

    # store results in data frame
    ParamEst = t(data.frame(Gomp_Linf=round(EstGomp_Linf,2), Gomp_G=round(Estvb_K,2),
                            StandDev=round(EstStandDev,2)))
    colnames(ParamEst) = c("Estimate","lw_95%CL","up_95%CL")

  }

  # store value of objective function
  nll = nlmb$objective

  # store convergence value
  convergence = nlmb$convergence

  # deltaL vs initial length
  CalculationStage = 1
  LenPrevIntAge = NA
  EstLenAtRelAge = rep(0, nobs)
  for (j in 1:nobs) {
    EstLenAtRelAge[j] = LenAtAge(j, params, GrowthCrvChoice, CalculationStage, LenPrevIntAge, StartAge=0,
                                 Obs_delta_t, Obs_Initlen, EstLenAtRelAge)
  }

  # estimate of annual growth increment vs specified initial length
  CalculationStage = 2
  LenInc = rep(0,MaxLen)
  for (j in 1:MaxLen)  {
    LenInc[j] = LenAtAge(j, params, GrowthCrvChoice, CalculationStage, LenPrevIntAge, StartAge=0,
                         Obs_delta_t, Obs_Initlen, EstLenAtRelAge) - j
  }

  # estimate of length at integer ages
  CalculationStage = 3
  EstLenAtIntAge <- rep(0, MaxAge)
  for (j in seq(1,MaxAge+1,1)) {
    if (j==1) {
      EstLenAtIntAge[j] = 0 # age zero
    } else {
      LenPrevIntAge = EstLenAtIntAge[j-1]
      EstLenAtIntAge[j] = LenAtAge(j, params, GrowthCrvChoice, CalculationStage, LenPrevIntAge, StartAge=0,
                                   Obs_delta_t, Obs_Initlen, EstLenAtRelAge)
    }
  }

  Obs_delta_Length = Obs_Finlen-Obs_Initlen
  Est_delta_Length = EstLenAtRelAge-Obs_Initlen
  Est_Final_Length = EstLenAtRelAge
  plot_Init_Length = 1:MaxLen
  plot_Length_Inc = LenInc
  plot_IntAge = 0:MaxAge
  plot_EstLenAtIntAge = EstLenAtIntAge

  # store all results as a list object
  results = list(nll = nll,
                 convergence = convergence,
                 ParamEst = ParamEst,
                 vcov.params = vcov.params,
                 Obs_delta_Length=Obs_delta_Length,
                 Est_delta_Length=Est_delta_Length,
                 Est_Final_Length=Est_Final_Length,
                 plot_Init_Length=plot_Init_Length,
                 plot_Length_Inc=plot_Length_Inc,
                 plot_IntAge=plot_IntAge,
                 plot_EstLenAtIntAge=plot_EstLenAtIntAge)
  return(results)

}

#' Plot fitted tagging growth model and data.
#'
#' This function fits a model to fish tag-recapture data
#' by minimising the negative log-likelihood associated with the parameters and data,
#' using nlminb. It provides various statistical outputs in include convergence statistics,
#' parameter estimated and associated 95% confidence limits and associated variance-covariance matrix,
#' calculated using the MASS package. Results are then plotted.
#' Function requires data for recorded times at liberty, initial and final lengths
#' of tagged and recaptured animals (stored in memory in R).
#' Obs_delta_t, Obs_Initlen, Obs_Finlen (Numeric Vectors)
#' @param  Model 1: L50_1, L95_1, L50_2, L95_2 (double logistic model)
# ' Model 2: Gaussian_A, Gaussian_u, Gaussian_sd (Gaussian function)
#'  Model 3: vb_Linf, vb_K (von Bertalanffy)
#'  Model 4: Gomp_Linf, Gomp_G
#' @return negative log-likelihood (nll)
#' nlminb convergence diagnostic (convergence)
#' sample size (SampleSize)
#' growth parameter estimates with lower and upper 95% confidence limits (ParamEst)
#' point estimates for growth parameters (params)
#' variance-covariance matrix (vcov.params)
#' @examples
#' set.seed(123)
#' MaxLen = 240
#' MaxAge = 20
#' Gaussian_A = 0.1
#' Gaussian_u = 80
#' Gaussian_sd = 40
#' StandDev = 10
#' GrowthCrvChoice = 2 # 1 = double logistic, 2 = Gaussian function, 3 = von Bertalanffy growth curve, 4 = Gompertz growth curve
#' params = log(c(Gaussian_A, Gaussian_u, Gaussian_sd, StandDev))
#' nSamples = 200
#' CalculationStage = 1
#' res=SimulateTagRecaptureData(GrowthCrvChoice, nSamples, MaxLen, MaxAge, params)
#' Obs_delta_t=res$Obs_delta_t
#' Obs_Initlen=res$Obs_Initlen
#' Obs_Finlen=res$Obs_Finlen
#' nobs = nSamples
#' params = log(c(0.1, 80, 40, 10))
#' PlotFittedTaggingGrowthModelResults(params, Obs_delta_t, Obs_Initlen, Obs_Finlen, nobs)
#' @export
PlotFittedTaggingGrowthModelResults <- function(params, Obs_delta_t, Obs_Initlen, Obs_Finlen, nobs) {

  res=GetTaggingGrowthModelResults(params, Obs_delta_t, Obs_Initlen, Obs_Finlen, nobs)
  params=log(as.vector(res$ParamEst[,1]))

  # deltaL vs initial length
  CalculationStage = 1
  LenPrevIntAge = NA
  EstLenAtRelAge = rep(0, nobs)
  for (j in 1:nobs) {
    EstLenAtRelAge[j] = LenAtAge(j, params, GrowthCrvChoice, CalculationStage, LenPrevIntAge, StartAge=0,
                                 Obs_delta_t, Obs_Initlen, EstLenAtRelAge)
  }

  par(mfrow = c(3,2), mar=c(4,4,2,2))
  plot(Obs_Initlen,Obs_Finlen-Obs_Initlen, cex=0.8, xlab = " Init. Len. (mm)", ylab = "Len. inc. (mm)", bty='n')
  points(Obs_Initlen,EstLenAtRelAge-Obs_Initlen, col="blue", cex=0.8)

  # initial length vs final length
  plot(Obs_Initlen,Obs_Finlen, cex=0.8, xlab = " Init. Len. (mm)", ylab = "Final inc. (mm)", bty='n')
  points(Obs_Initlen,EstLenAtRelAge, col="blue")

  # res vs initial length
  plot(Obs_Initlen, Obs_Finlen-EstLenAtRelAge, cex=0.8, xlab = " Init. len (mm)", ylab = "Residual (mm)", bty='n')

  # res vs delta_t
  plot(Obs_delta_t, Obs_Finlen-EstLenAtRelAge, cex=0.8, xlab = " Delta_t (days)", ylab = "Residual (mm)", bty='n')

  # estimate of annual growth increment vs specified initial length
  CalculationStage = 2
  LenInc = rep(0,MaxLen)
  for (j in 1:MaxLen)  {
    LenInc[j] = LenAtAge(j, params, GrowthCrvChoice, CalculationStage, LenPrevIntAge, StartAge=0,
                         Obs_delta_t, Obs_Initlen, EstLenAtRelAge) - j
  }
  plot(1:MaxLen, LenInc, "l", ylim=c(0,60), cex=0.0,
       xlab = " Init. len. (mm)", ylab = "Est. ann. inc. (mm)", bty='n')

  # estimate of length at integer ages
  CalculationStage = 3
  EstLenAtIntAge <- rep(0, MaxAge)
  for (j in seq(1,MaxAge+1,1)) {
    if (j==1) {
      EstLenAtIntAge[j] = 0 # age zero
    } else {
      LenPrevIntAge = EstLenAtIntAge[j-1]
      EstLenAtIntAge[j] = LenAtAge(j, params, GrowthCrvChoice, CalculationStage, LenPrevIntAge, StartAge=0,
                                   Obs_delta_t, Obs_Initlen, EstLenAtRelAge)
    }
  }

  plot(0:MaxAge,EstLenAtIntAge,ylim=c(0,240), xlab = " Age (yrs)", ylab = "len. at age (mm)", bty='n')
  lines(0:MaxAge,EstLenAtIntAge, col="blue")
}


#*********************************
# Gonadosomatic index calculations
#*********************************

#' Get mean monthly GSI values and associated 95 percent confidence limits
#'
#' @param data frame, for given sex (FishRepdat), including elements length at first maturity (MatL50), data frame
#' containing data for individual fish, including month of capture (MM), fish length (FishLen),
#' gonad wet weight (GonadWt) and fish total body weight (FishWt)
#' @return data frame (Result) containing elements month (MM), mean GSI (Mean), standard
#' deviation (sd), monthly sample size (n), standard error (se), lower and upper 95 percent
#' confidence limits (Low95 and Up95)
#' @examples
#' set.seed(123)
#' nMnths = 12
#' MnthSampeSizes = 20
#' MMSampSize = rep(MnthSampeSizes,nMnths)
#' TotSampSize = MnthSampeSizes * nMnths
#' Mnths = 1:nMnths
#' MeanMMGSI = rep(c(rep(0.1,4),0.25, 0.7, 0.6, 0.3, rep(0.1,4)),MMSampSize)
#' randMMGSI = rnorm(TotSampSize,MeanMMGSI,0.1)
#' length(randMMGSI)
#' MM = rep(Mnths,times=MMSampSize)
#' FishLen = round(runif(TotSampSize,100,500),0)
#' FishWt = (0.0000001 * FishLen ^ 3)
#' GonadWt = (randMMGSI / 100) * FishWt
#' FishRepdat = data.frame(MM=MM, FishLen=FishLen, GonadWt=GonadWt, FishWt=FishWt)
#' MatL50 = 200
#' CalcMeanMonthlyGSIs(MatL50, FishRepdat)
#' @export
CalcMeanMonthlyGSIs <- function(MatL50, FishRepdat) {

  # subset data for females above our guess at size at maturity
  subdat = FishRepdat[FishRepdat$FishLen>=MatL50,]

  # calculate GSIs for individual fish
  subdat$GSI = (subdat$GonadWt / subdat$FishWt) * 100

  # monthly means
  temp <- aggregate(GSI ~ MM, subdat, FUN=mean)
  Mnth = temp[,1]
  MeanGSI = temp[,2]

  # monthly counts
  temp <- aggregate(GSI ~ MM, subdat, FUN=length)
  nGSI = temp[,2]

  # monthly standard deviations
  temp <- aggregate(GSI ~ MM, subdat, FUN=sd)
  sdGSI = temp[,2]

  # create single data frame with desired fields
  Result <- data.frame(Mnth=Mnth,
                       MeanGSI=MeanGSI,
                       sdGSI=sdGSI,
                       nGSI=nGSI)

  # calculate standard error
  Result$seGSI <- Result$MeanGSI / sqrt(Result$nGSI)

  # calculate lower and upper 95% CLS, assuming GSI data normally distributed
  Result$Low95GSI <- Result$MeanGSI - (1.96 * Result$seGSI)
  Result$Up95GSI <- Result$MeanGSI + (1.96 * Result$seGSI)

  return(Result)

}

#' Plot mean monthly GSI values and associated 95 percent confidence limits
#'
#' @param data frame, for given sex (FishRepdat), including elements length at first maturity (MatL50), data frame
#' containing data for individual fish, including month of capture (MM), fish length (FishLen),
#' gonad wet weight (GonadWt) and fish total body weight (FishWt), and various plotting elements
#' @return plot of maturity data
#' @examples
#' set.seed(123)
#' nMnths = 12
#' MnthSampeSizes = 20
#' MMSampSize = rep(MnthSampeSizes,nMnths)
#' TotSampSize = MnthSampeSizes * nMnths
#' Mnths = 1:nMnths
#' MeanMMGSI = rep(c(rep(0.1,4),0.25, 0.7, 0.6, 0.3, rep(0.1,4)),MMSampSize)
#' randMMGSI = rnorm(TotSampSize,MeanMMGSI,0.1)
#' length(randMMGSI)
#' MM = rep(Mnths,times=MMSampSize)
#' FishLen = round(runif(TotSampSize,100,500),0)
#' FishWt = (0.0000001 * FishLen ^ 3)
#' GonadWt = (randMMGSI / 100) * FishWt
#' GSIdat = data.frame(MM=MM, FishLen=FishLen, GonadWt=GonadWt, FishWt=FishWt)
#' MatL50 = 200
#' PlotGSIData(MatL50, GSIdat, ymax=NA, yint=NA, GraphTitle="Females",
#'                                 xaxis_lab="Month",yaxis_lab="Mean GSI")
#' @export
PlotGSIData <- function(MatL50, FishRepdat, ymax, yint, GraphTitle,
                        xaxis_lab="Mean GSI", yaxis_lab="Month") {

  res=CalcMeanMonthlyGSIs(MatL50, FishRepdat)

  if (is.na(ymax)) {
    ymax = 2 + trunc(ceiling(max(res$Up95))/2)*2
  }
  if (is.na(yint)) {
    yint = 2
  }

  plot(res$Mnth, res$Mean, "o", pch=16, frame=F, xlim = c(1,12), ylim = c(0,ymax),
       xaxt='n', yaxt="n", xlab=xaxis_lab, ylab=yaxis_lab, main=GraphTitle)
  arrows(res$Mnth,res$Low95,res$Mnth,res$Up95,
         code=3, angle=90, length=0.03)
  axis(1, at=1:12, tck=0.03, cex=0.5, labels=F,line=0.5)
  axis(1, at=1:12, tck=0.03, cex=0.5, labels=T,line=0, lwd=0)
  axis(2, at=seq(0, ymax, yint), tck=0.03, cex=0.5, labels=F,line=0.5)
  axis(2, at=seq(0, ymax, yint), tck=0.03, cex=0.5, labels=T,line=0, lwd=0, las=2)

}


#' Calculate monthly proportions of each gonad stage
#'
#' @param data frame (FishRepdat), including elements length at first maturity (MatL50), data frame
#' containing data for individual fish, including month of capture (MM), fish length (FishLen),
#' gonad wet weight (GonadWt), gonad development stages (GonadSt) and fish total body weight (FishWt)
#' @return Monthly gonad stage proportions, PropGonadSt (Vector), list of gonad stages, GonadStages (Vector))
#' @export
CalcMonthlyGonadStageProps <- function(MatL50, FishRepdat) {

  # subset data for fish above L50
  subdat = FishRepdat[FishRepdat$FishLen>=MatL50,]

  # calculate numbers of fish with each gonadal stage, caught in each month
  Table1 = table(factor(subdat$MM, levels=1:12), subdat$GonadSt)

  MinGonadStage = min(subdat$GonadSt)
  MaxGonadStage = max(subdat$GonadSt)
  GonadStages = MinGonadStage:MaxGonadStage

  # calculate monthly proportions of each gonad stage
  PropGonadSt = data.frame(matrix(nrow=12, ncol=length(GonadStages)))
  colnames(PropGonadSt) = GonadStages

  par(mfcol=c(3,3), mar=c(5,4,2,2), oma=c(1,1,1,1))
  for (i in GonadStages) {
    PropGonadSt[,i] = Table1[,i] / rowSums(Table1)
    x=which(is.nan(PropGonadSt[,i]))
    if (length(x) > 0) {
      PropGonadSt[x,i]=0
    }
  }

  Results = list(PropGonadSt=PropGonadSt,
                 GonadStages=GonadStages)

  return(Results)
}

#' Plot monthly proportions of fish gonad stages
#'
#' @param data frame (FishRepdat), including elements length at first maturity (MatL50), data frame
#' containing data for individual fish, including month of capture (MM), fish length (FishLen),
#' gonad wet weight (GonadWt), gonad development stages (GonadSt) and fish total body weight (FishWt)
#' @return plot of monthly proportions of fish gonad stages
#' @export
PlotMonthlyGonadStageProps <- function(MatL50, FishRepdat) {

  res=CalcMonthlyGonadStageProps(MatL50, FishRepdat)
  PropGonadSt=res$PropGonadSt
  GonadStages=res$GonadStages

  par(mfcol=c(3,3), mar=c(5,4,2,2), oma=c(1,1,1,1))
  for (i in GonadStages) {
    plot(1:12,PropGonadSt[,i],"o", xlim=c(1,12), ylim=c(0,1), cex.main=1, main=paste("Gonad stage",i),
         xlab="Month", ylab="Proportion", bty='n', yaxt="n",xaxt="n")
    axis(1,at=seq(1,12,1), cex.axis=1, lwd=1.75,lab=F) # y axis
    axis(1,at=seq(1,12,1), labels=seq(1,12,1),cex.axis=1,line=0,las=1,lwd=1.5,tick=F) #add y labels
    axis(2,at=seq(0,1,0.2), cex.axis=1, lwd=1.75,lab=F) # y axis
    axis(2,at=seq(0,1,0.2), cex.axis=1,line=0,las = 1,lwd=1.5,tick=F) #add y labels
  }
}


#*******************
# LENGTH AT MATURITY
#*******************


LogisticEqnLengthAtMaturity <- function(params) {
  # for estimation
  L50=params[1]
  L95=params[2]
  results = 1.0 / (1.0 + exp(- log(19) * (ObsLen - L50) / (L95 - L50)))
  return(results)
}

LogisticEqnLengthAtMaturity2 <- function(params) {
  # for plotting
  L50=params[1]
  L95=params[2]
  results = 1.0 / (1.0 + exp(- log(19) * (plotlengths - L50) / (L95 - L50)))
  return(results)
}

LogisticEqnAgeAtMaturity <- function(params) {
  # for estimation
  A50=params[1]
  A95=params[2]
  results = 1.0 / (1.0 + exp(- log(19) * (ObsAgeCl - A50) / (A95 - A50)))
  return(results)
}

LogisticEqnAgeAtMaturity2 <- function(params) {
  # for plotting
  A50=params[1]
  A95=params[2]
  results = 1.0 / (1.0 + exp(- log(19) * (plotages - A50) / (A95 - A50)))
  return(results)
}

#' Simulate length at maturity data given specified growth and size at maturity parameters.
#'
#' @param params nSamples (Number), MaxAge (Number), Linf (Number), vbK (Number), tzero (Number),
#' MinLen (Number), MaxLen (Number), LenInc (Number), L50 (Number), L95 (Number)
#' @return Random fish lengths, ObsLen (Vector), maturity category, 1 or 0, ObsMatCat (Vector),
#' length class lower bound, lbnd (Vector), length class mid point (midpt), proportion mature in length class,
#' PropMat (Vector),  plotlengths (lengths to plot maturity curve)
#' @examples
#' # generate some synthetic maturity data
#' set.seed(123)
#' MaxAge = 20
#' nSamples = 300
#' Linf = 300
#' vbK = 0.3
#' tzero = 0
#' CVSizeAtAge = 0.1
#' MinLen = 0
#' MaxLen = 400
#' LenInc = 20
#' L50 = 220
#' L95 = 270
#' SimulateLengthAtMaturityData(nSamples, MaxAge, Linf, vbK, tzero, MinLen, MaxLen, LenInc, L50, L95)
#' @export
SimulateLengthAtMaturityData <- function(nSamples, MaxAge, Linf, vbK, tzero, MinLen, MaxLen, LenInc,
                                 L50, L95) {

  ObsAge = runif(nSamples, 1, MaxAge)
  MeanLen = Linf * (1 - exp(-vbK * (ObsAge - tzero)))
  ObsLen = rnorm(nSamples, MeanLen, CVSizeAtAge * MeanLen)

  # set up length bins
  lbnd = seq(MinLen,MaxLen,LenInc)
  midpt = lbnd + LenInc/2
  nLenCl = length(lbnd)
  ObsLenCats = trunc(ObsLen/LenInc)+1

  # assign random probabilities of maturity, given specified length
  # at maturity relationship
  ObsLen = round(ObsLen,0)
  nLenObs = length(ObsLen)
  rnd = runif(nLenObs,0,1)
  ObsMatCat = rep(NA, nLenObs)
  ProbMat = 1 / (1 + exp(-log(19) * (ObsLen - L50) / (L95 - L50)))
  for (i in 1:nLenObs) {
    if (rnd[i] <= ProbMat[i]) {
      ObsMatCat[i] = 1
    } else {
      ObsMatCat[i] = 0
    }
  }
  ObsFreqImm = rep(0,nLenCl)
  ObsFreqMat = rep(0,nLenCl)
  for (i in 1:nLenCl) {
    ObsFreqImm[i] <- length(which(ObsLenCats==i & ObsMatCat==0) )
    ObsFreqMat[i] <- length(which(ObsLenCats==i & ObsMatCat==1) )
  }
  LenClSampSize = ObsFreqMat + ObsFreqImm
  PropMat = ObsFreqMat / (ObsFreqMat + ObsFreqImm)

  # find length cut-offs for plotting
  lw = midpt[min(which(!is.nan(PropMat)))]
  hi = midpt[max(which(!is.nan(PropMat)))]
  plotlengths = lw:hi

  results = list(ObsLen = ObsLen,
                 ObsMatCat = ObsMatCat,
                 lbnd = lbnd,
                 midpt = midpt,
                 PropMat = PropMat,
                 plotlengths = plotlengths,
                 LenClSampSize = LenClSampSize)
  return(results)
}


#' Simulate age at maturity data
#'
#' @param params Random fish decimal ages ObsAge (Vector), maturity category, 1 or 0 ObsMatCat (Vector),
#' AgeClasses (Vector), Proportion mature in age class PropMat (Vector),
#' Ages for plotting, excluding any NAs plotages (Vector),
#' numbers of fish in each age class AgeClSampSize  (Vector)
#' @examples
#' # generate some synthetic maturity data
#' set.seed(123)
#' MinAge = 0
#' MaxAge = 20
#' nSamples = 300
#' A50 = 4
#' A95 = 6
#' SimulateAgeAtMaturityData(nSamples, MinAge, MaxAge, A50, A95)
#' @export
SimulateAgeAtMaturityData <- function(nSamples, MinAge, MaxAge, A50, A95) {

  # generate random integer values between MinAge and MaxAge (ignoring selectivity, survival etc.)
  ObsAgeCl = round(runif(nSamples, MinAge, MaxAge),0)

  # assign random probabilities of maturity, given specified length
  # at maturity relationship
  nAgeObs = length(ObsAgeCl)
  AgeClasses = MinAge:MaxAge
  nAgeClasses = length(AgeClasses)
  rnd = runif(nAgeObs,0,1)

  ObsMatCat = rep(NA, nAgeObs)
  ProbMat = 1 / (1 + exp(-log(19) * (ObsAgeCl - A50) / (A95 - A50)))
  for (i in 1:nAgeObs) {
    if (rnd[i] <= ProbMat[i]) {
      ObsMatCat[i] = 1
    } else {
      ObsMatCat[i] = 0
    }
  }

  ObsFreqImm = rep(0,nAgeClasses)
  ObsFreqMat = rep(0,nAgeClasses)
  k=0
  for (i in AgeClasses) {
    k=k+1
    ObsFreqImm[k] <- length(which(ObsAgeCl==i & ObsMatCat==0) )
    ObsFreqMat[k] <- length(which(ObsAgeCl==i & ObsMatCat==1) )
  }
  PropMat = ObsFreqMat / (ObsFreqMat + ObsFreqImm)
  AgeClSampSize = ObsFreqMat + ObsFreqImm

  # find length cut-offs for plotting
  lw = AgeClasses[min(which(!is.nan(PropMat)))]
  hi = AgeClasses[max(which(!is.nan(PropMat)))]
  plotages = seq(lw,hi,0.1)

  results = list(ObsAgeCl = ObsAgeCl,
                 ObsMatCat = ObsMatCat,
                 AgeClasses = AgeClasses,
                 PropMat = PropMat,
                 plotages = plotages,
                 AgeClSampSize = AgeClSampSize)
  return(results)
}


#' Calculate negative log-likelihood for a length-based logistic maturity curve.
#'
#' Calculates the negative log-likelihood associated with a sample of fish maturity-at-length data
#' and logistic maturity parameter values. Function requires observed length and maturity category
#' (0=immature, 1=mature) data for individual fish (stored in memory in R).
#' ObsLen, ObsMatCat (Numeric Vectors)
#' This function (with parameter inputs) can be passed into R optimisation routines (e.g. nlminb).
#' @keywords internal
#' @param params Length at 50 percent maturity (L50), length at 95 percent maturity (L95), Numbers.
#' @return Negative-log likelihood associated with logistic curve fit to maturity-at-length data
CalcNLL_LogisticLengthAtMaturity <- function(params) {

  nObs = length(ObsLen)
  L50 = params[1]
  L95 = params[2]

  # calculate likelihood
  ProbMat = LogisticEqnLengthAtMaturity(params)

  Likelihood <- rep(NA,nObs)
  x=which(ObsMatCat==1)
  Likelihood[x] = ProbMat[x]
  x=which(ObsMatCat==0)
  Likelihood[x] <- 1 - ProbMat[x]
  Likelihood[which(Likelihood==0)]=1E-4
  LL <- log(Likelihood)

  # calculate the negative log-likelihood
  NLL = -sum(LL)

  # set function result to NLL
  results = NLL

  return(results)

}

#' Calculate negative log-likelihood for an age-based logistic maturity curve.
#'
#' Calculates the negative log-likelihood associated with a sample of fish maturity-at-age data
#' and logistic maturity parameter values (or sex change data).
#' Function requires observed age class and maturity category
#' (0=immature, 1=mature) data for individual fish (stored in memory in R).
#' ObsAgeCl, ObsMatCat (Numeric Vectors)
#' This function (with parameter inputs) can be passed into R optimisation routines (e.g. nlminb).
#' @keywords internal
#' @param params Age at 50 percent maturity (A50), age at 95 percent maturity (A95), Numbers.
#' @return Negative-log likelihood associated with logistic curve fit to maturity-at-age data
CalcNLL_LogisticAgeAtMaturity <- function(params) {

  nObs = length(ObsAgeCl)
  A50 = params[1]
  A95 = params[2]

  # calculate likelihood
  ProbMat = LogisticEqnAgeAtMaturity(params)

  Likelihood <- rep(NA,nObs)
  x=which(ObsMatCat==1)
  Likelihood[x] = ProbMat[x]
  x=which(ObsMatCat==0)
  Likelihood[x] <- 1 - ProbMat[x]
  Likelihood[which(Likelihood==0)]=1E-4
  LL <- log(Likelihood)

  # calculate the negative log-likelihood
  NLL = -sum(LL)

  # set function result to NLL
  results = NLL

  return(results)

}

#' Fit a length-based maturity curve to fish maturity-at-length data.
#'
#' This function fits a logistic maturity curve to a sample of maturity-at-length data
#' by minimising the negative log-likelihood associated with the parameters and data, using nlminb.
#' Function requires observed length and maturity category
#' (0=immature, 1=mature) data for individual fish (stored in memory in R).
#' ObsLen, ObsMatCat (Numeric Vectors)
#' @keywords internal
#' @param params Length at 50 and 95 percent maturity, L50 and L95 (Vector), observed lengths,
#' ObsLen (Vector), Observed maturity category (0=immature, 1=mature) (Vector)
#' @return nlmb (stored output from internal R nlminb optimisation function)
FitLogisticLengthAtMaturityCurve <- function(params, ObsLen, ObsMatCat) {

  # run nlminb
  nlmb <- nlminb(params, CalcNLL_LogisticLengthAtMaturity, gradient = NULL, hessian = TRUE,
                 control=list(trace=1))
  results = nlmb

  return(results)

}

#' Fit an age-based maturity curve to fish maturity-at-age data.
#'
#' This function fits a logistic maturity curve to a sample of maturity-at-age data
#' by minimising the negative log-likelihood associated with the parameters and data, using nlminb.
#' Function requires observed length and maturity category
#' (0=immature, 1=mature) data for individual fish (stored in memory in R).
#' ObsLen, ObsMatCat (Numeric Vectors)
#' @keywords internal
#' @param params Age at 50 and 95 percent maturity, L50 and L95 (Vector), observed age classes,
#' ObsAgeCl (Vector), Observed maturity category (0=immature, 1=mature) (Vector)
#' @return nlmb (stored output from internal R nlminb optimisation function)
FitLogisticAgeAtMaturityCurve <- function(params, ObsAgeCl, ObsMatCat) {

  # run nlminb
  nlmb <- nlminb(params, CalcNLL_LogisticAgeAtMaturity, gradient = NULL, hessian = TRUE,
                 control=list(trace=1))
  results = nlmb

  return(results)

}

#' Calculate proportions of fish mature in successive length classes
#'
#' @param maximum fish length, MaxLen (Number), length class size increment, LenInc (Number),
#' Observed fish lengths, ObsLen (Vector), Observed maturity category, ObsMatCat, where 0 is
#' immature and 1 is mature (Vector)
#' @return length class lower bounds, lbnd (Vector), length class mid points, midpt (Vector),
#' proportions of mature fish in successive length classes, PropMat (Vector), range of lengths
#' for plotting maturity curve when estimated, i.e. range of data, plotlengths (Vector),
#' length class sample sizes, LenClSampSize (Vector)
#' @examples
#' # generate some synthetic maturity data
#' MaxAge = 20
#' nSamples = 300
#' Linf = 300
#' vbK = 0.3
#' tzero = 0
#' CVSizeAtAge = 0.1
#' MinLen = 0
#' MaxLen = 400
#' LenInc = 20
#' L50 = 220
#' L95 = 270
#' res=SimulateLengthAtMaturityData(nSamples, MaxAge, Linf, vbK, tzero, MinLen, MaxLen, LenInc, L50, L95)
#' ObsLen=res$ObsLen
#' ObsMatCat=res$ObsMatCat
#' CalcPropMatureAtLength(MaxLen, LenInc, ObsLen, ObsMatCat)
#' @export
CalcPropMatureAtLength <- function(MaxLen, LenInc, ObsLen, ObsMatCat) {

  MinLen=0
  lbnd = seq(MinLen, MaxLen, LenInc)
  midpt = lbnd + LenInc/2
  nLenCl = length(lbnd)
  ObsLenCats = trunc(ObsLen/LenInc) + 1
  ObsFreqImm = rep(0, nLenCl)
  ObsFreqMat = rep(0, nLenCl)
  for (i in 1:nLenCl) {
    ObsFreqImm[i] <- length(which(ObsLenCats == i & ObsMatCat ==
                                    0))
    ObsFreqMat[i] <- length(which(ObsLenCats == i & ObsMatCat ==
                                    1))
  }
  LenClSampSize = ObsFreqMat + ObsFreqImm
  PropMat = ObsFreqMat/(ObsFreqMat + ObsFreqImm)
  lw = midpt[min(which(!is.nan(PropMat)))]
  hi = midpt[max(which(!is.nan(PropMat)))]
  plotlengths = lw:hi

  results = list(lbnd = lbnd, midpt = midpt, PropMat = PropMat, plotlengths = plotlengths,
                 LenClSampSize = LenClSampSize)

  return(results)
}

#' Calculate proportions of fish mature in successive age classes
#'
#' @param maximum minimum age class, MinAge (Number), maximum age class, MaxAge (Number),
#' Observed fish age classes, ObsAgeCl (Vector), Observed maturity category, ObsMatCat, where 0 is
#' immature and 1 is mature (Vector)
#' @return Age classes, AgeClasses (Vector), proportions of mature fish in successive age classes,
#' PropMat (Vector), range of age classes for plotting maturity curve when estimated, i.e. range
#' of data, plotlengths (Vector), age class sample sizes, AgeClSampSize (Vector)
#' @examples
#' # generate some synthetic maturity data
#' MinAge = 0
#' MaxAge = 20
#' nSamples = 300
#' A50 = 4
#' A95 = 6
#' res=SimulateAgeAtMaturityData(nSamples, MinAge, MaxAge, A50, A95)
#' ObsAgeCl=res$ObsAgeCl
#' ObsMatCat=res$ObsMatCat
#' CalcPropMatureAtAge(MinAge, MaxAge, ObsAgeCl, ObsMatCat)
#' @export
CalcPropMatureAtAge <- function(MinAge, MaxAge, ObsAgeCl, ObsMatCat) {

  AgeClasses = MinAge:MaxAge
  nAgeClasses  = length(AgeClasses)
  ObsFreqImm = rep(0, nAgeClasses)
  ObsFreqMat = rep(0, nAgeClasses)
  k = 0
  for (i in AgeClasses) {
    k = k + 1
    ObsFreqImm[k] <- length(which(ObsAgeCl == i & ObsMatCat == 0))
    ObsFreqMat[k] <- length(which(ObsAgeCl == i & ObsMatCat == 1))
  }
  PropMat = ObsFreqMat/(ObsFreqMat + ObsFreqImm)
  AgeClSampSize = ObsFreqMat + ObsFreqImm
  lw = AgeClasses[min(which(!is.nan(PropMat)))]
  hi = AgeClasses[max(which(!is.nan(PropMat)))]
  plotages = seq(lw, hi, 0.1)
  results = list(AgeClasses = AgeClasses, PropMat = PropMat, plotages = plotages,
                 AgeClSampSize = AgeClSampSize)
  return(results)
}


#' Get statistical outputs from a fitted logistic maturity curve.
#'
#' This function fits a logistic maturity curve to a sample of maturity-at-length data
#' by minimising the negative log-likelihood associated with the parameters and data, using nlminb.
#' It provides various statistical outputs in include convergence statistics,
#' parameter estimated and associated 95 percent confidence limits and associated variance-covariance matrix,
#' calculated using the MASS package.
#' Function requires observed length and maturity category
#' (0=immature, 1=mature) data for individual fish (stored in memory in R).
#' ObsLen, ObsMatCat (Numeric Vectors)
#' @param params Length at 50 percent maturity (L50), length at 95 percent maturity (L95), Numbers.
#' @return negative log-likelihood (nll)
#' nlminb convergence diagnostic (convergence)
#' sample size (SampleSize)
#' maturity parameter estimates with lower and upper 95 percent confidence limits (ParamEst)
#' point estimates for growth parameters (params)
#' variance-covariance matrix (vcov.params)
#' @examples
#' #Generate some synthetic length-at-maturity data and fit
#' #length-based maturity curve
#' MaxAge = 20
#' nSamples = 500
#' Linf = 300
#' vbK = 0.3
#' tzero = 0
#' CVSizeAtAge = 0.1
#' MinLen = 0
#' MaxLen = 400
#' LenInc = 20
#' L50 = 220
#' L95 = 270
#' res=SimulateLengthAtMaturityData(nSamples, MaxAge, Linf, vbK, tzero, MinLen, MaxLen, LenInc, L50, L95)
#' ObsAgeCl=NA
#' ObsLen=res$ObsLen
#' ObsMatCat=res$ObsMatCat
#' params = c(L50, L95)
#' LogisticModType = 1 # 1=length, 2=age
#' GetLogisticMaturityCurveResults(params, LogisticModType, ObsLen, ObsAgeCl, ObsMatCat) # get length-at-maturity results
#'
#' # Generate some synthetic age-at-maturity data and fit
#' # age-based maturity curve
#' MinAge = 0
#' MaxAge = 20
#' nSamples = 500
#' A50 = 4
#' A95 = 6
#' res=SimulateAgeAtMaturityData(nSamples, MinAge, MaxAge, A50, A95)
#' ObsLen=NA
#' ObsAgeCl=res$ObsAgeCl
#' ObsMatCat=res$ObsMatCat
#' params = c(A50, A95)
#' LogisticModType = 2 # 1=length, 2=age
#' GetLogisticMaturityCurveResults(params, LogisticModType, ObsLen, ObsAgeCl, ObsMatCat) # get age-at-maturity results
#' @export
GetLogisticMaturityCurveResults <- function(params, LogisticModType, ObsLen, ObsAgeCl, ObsMatCat) {

  # fit maturity curve
  if (LogisticModType==1) {
    nlmb = FitLogisticLengthAtMaturityCurve(params, ObsLen, ObsMatCat)
  }
  if (LogisticModType==2) {
    nlmb = FitLogisticAgeAtMaturityCurve(params, ObsAgeCl, ObsMatCat)
  }

  # get estimates
  # nlmb$objective # value of nll
  # nlmb$convergence

  # get variance-covariance matrix, from fitted model, to get standard errors
  if (LogisticModType==1) {
  hess.out = optimHess(params, CalcNLL_LogisticLengthAtMaturity)
  }
  if (LogisticModType==2) {
    hess.out = optimHess(params, CalcNLL_LogisticAgeAtMaturity)
  }

  params = nlmb$par
  vcov.params = solve(hess.out)
  ses = sqrt(diag(vcov.params)) # get asymptotic standard errors of parameter estimates

  # calculate 95 percent confidence limits
  if (LogisticModType==1) { # length at maturity
    EstL50 = c(nlmb$par[1], nlmb$par[1] + c(-1.96, 1.96) * ses[1])
    EstL95 = c(nlmb$par[2], nlmb$par[2] + c(-1.96, 1.96) * ses[2])

    # store results in data frame
    ParamEst = t(data.frame(L50=round(EstL50,2), L95=round(EstL95,2)))
    colnames(ParamEst) = c("Estimate","lw_95%CL","up_95%CL")

    # store sample size
    SampleSize = length(ObsLen)
  }
  if (LogisticModType==2) { # age at maturity
    EstA50 = c(nlmb$par[1], nlmb$par[1] + c(-1.96, 1.96) * ses[1])
    EstA95 = c(nlmb$par[2], nlmb$par[2] + c(-1.96, 1.96) * ses[2])

    # store results in data frame
    ParamEst = t(data.frame(A50=round(EstA50,2), A95=round(EstA95,2)))
    colnames(ParamEst) = c("Estimate","lw_95%CL","up_95%CL")

    # store sample size
    SampleSize = length(ObsAgeCl)
  }

  # store value of objective function
  nll = nlmb$objective

  # store convergence value
  convergence = nlmb$convergence

  # store all results as a list object
  results = list(nll = nll,
                 convergence = convergence,
                 SampleSize = SampleSize,
                 ParamEst = ParamEst,
                 params = params,
                 vcov.params = vcov.params)
  return(results)

}

#' Plot observed fish maturity-at-length data.
#'
#' @param params  midpt (Vector), PropMat (Vector), LenClSampSize (Vector),
#' ymax (Number), xmax (Number), GraphTitle (String), xaxis_lab (String), yaxis_lab (String)
#' @return scatter plot of maturity-at-length data.
#' @examples
#'# Generate some synthetic length-at-maturity data and plot
#'# length-at-maturity data
#' MaxAge = 20
#' nSamples = 500
#' Linf = 300
#' vbK = 0.3
#' tzero = 0
#' CVSizeAtAge = 0.1
#' MinLen = 0
#' MaxLen = 400
#' LenInc = 20
#' L50 = 220
#' L95 = 270
#' res=SimulateLengthAtMaturityData(nSamples, MaxAge, Linf, vbK, tzero, MinLen, MaxLen, LenInc, L50, L95)
#' midpt = res$midpt
#' PropMat = res$PropMat
#' LenClSampSize=res$LenClSampSize
#' xmax=MaxLen
#' xint=50
#' GraphTitle=NA
#' xaxis_lab=NA
#' yaxis_lab=NA
#' PlotLengthAtMaturityData(midpt, PropMat, LenClSampSize, xmax, xint,
#'                          GraphTitle, xaxis_lab, yaxis_lab)
#' @export
PlotLengthAtMaturityData <- function(midpt, PropMat, LenClSampSize, xmax, xint,
                                     GraphTitle, xaxis_lab, yaxis_lab) {

  if (is.na(xmax)) {
    xmax = 50 + trunc(ceiling(max(ObsLen))/50)*50
  }
  if (is.na(xint)) {
    xint = 50
  }
  if (is.na(xaxis_lab)) {
    xaxis_lab = "Total length, mm"
  }
  if (is.na(yaxis_lab)) {
    yaxis_lab = "Prop. mature"
  }

  plot(midpt,PropMat, xlim=c(0,xmax), ylim=c(0,1.2),
       frame=F, xaxt='n', yaxt='n', xlab=xaxis_lab, ylab=yaxis_lab, main=GraphTitle)
  axis(1,at=seq(0,xmax,xint),line=0.2, labels=F)
  axis(2,at=seq(0,1,0.2), line=0.2, labels=F)
  axis(1,at=seq(0,xmax,xint),lwd=0, labels=T, line=0,cex.axis=0.8, las=1)
  axis(2,at=seq(0,1,0.2), lwd=0, labels=T, line=0,cex.axis=0.8, las=1)
  text(midpt,PropMat+0.05,LenClSampSize,cex=0.7)
}

#' Plot observed fish maturity-at-age data.
#'
#' @param params  AgeCl (Vector), PropMat (Vector), AgeClSampSize (Vector),
#' ymax (Number), xmax (Number), GraphTitle (String), xaxis_lab (String), yaxis_lab (String)
#' @return scatter plot of maturity-at-length data.
#' @examples
#' # generate some synthetic age-at-maturity data and plot
#' # age-at-maturity data
#' MinAge = 0
#' MaxAge = 20
#' nSamples = 500
#' A50 = 4
#' A95 = 6
#' res=SimulateAgeAtMaturityData(nSamples, MinAge, MaxAge, A50, A95)
#' AgeCl = res$AgeClasses
#' PropMat = res$PropMat
#' AgeClSampSize=res$AgeClSampSize
#' xmax=MaxAge
#' xint=2
#' GraphTitle=NA
#' xaxis_lab=NA
#' yaxis_lab=NA
#' PlotAgeAtMaturityData(AgeCl, PropMat, AgeClSampSize, xmax, xint,
#'                       GraphTitle, xaxis_lab, yaxis_lab)
#' @export
PlotAgeAtMaturityData <- function(AgeCl, PropMat, AgeClSampSize, xmax, xint,
                                  GraphTitle, xaxis_lab, yaxis_lab) {

  if (is.na(xmax)) {
    xmax = 50 + trunc(ceiling(max(ObsLen))/50)*50
  }
  if (is.na(xint)) {
    xint = 50
  }
  if (is.na(xaxis_lab)) {
    xaxis_lab = "Total length, mm"
  }
  if (is.na(yaxis_lab)) {
    yaxis_lab = "Prop. mature"
  }

  plot(AgeCl,PropMat, xlim=c(0,xmax), ylim=c(0,1.2),
       frame=F, xaxt='n', yaxt='n', xlab=xaxis_lab, ylab=yaxis_lab, main=GraphTitle)
  axis(1,at=seq(0,xmax,xint),line=0.2, labels=F)
  axis(2,at=seq(0,1,0.2), line=0.2, labels=F)
  axis(1,at=seq(0,xmax,xint),lwd=0, labels=T, line=0,cex.axis=0.8, las=1)
  axis(2,at=seq(0,1,0.2), lwd=0, labels=T, line=0,cex.axis=0.8, las=1)
  text(AgeCl,PropMat+0.05,AgeClSampSize,cex=0.7)
}

#' Use resampling to get confidence limits for the fitted maturity curve.
#'
#' @param GrowthEqn params (Vector), vcov.params (Matrix), LogisticModType (Integer)
#' @return scatter plot of length-at-age data
#' @export
GetConfidenceLimitsForMaturityCurve <- function(params, vcov.params, LogisticModType, plotlengths, plotages) {

  # store estimated parameter distributions
  set.seed(123)
  sims = data.frame(MASS::mvrnorm(n = 500, params, vcov.params))

  if (LogisticModType==1) {
    names(sims) = c("L50", "L95")
    sims.mat = apply(X=sims[,], MARGIN=1, FUN=LogisticEqnLengthAtMaturity2)
    sim.mat.xvals = plotlengths
  }
  if (LogisticModType==2) {
    names(sims) = c("A50", "A95")
    sims.mat = apply(X=sims[,], MARGIN=1, FUN=LogisticEqnAgeAtMaturity2)
    sim.mat.xvals = plotages

  }

  # Calculating the 2.5th an 97.5th percentile
  sim.mat.est = apply(sims.mat, 1, function(x) quantile(x, 0.5))
  sim.mat.low = apply(sims.mat, 1, function(x) quantile(x, 0.025))
  sim.mat.up = apply(sims.mat, 1, function(x) quantile(x, 0.975))

  results = list(sim.mat.est = sim.mat.est,
                 sim.mat.low = sim.mat.low,
                 sim.mat.up = sim.mat.up,
                 sim.mat.xvals = sim.mat.xvals,
                 sims.params = sims,
                 sims.curves = sims.mat)

  return(results)

}

#' Plot fitted logistic curve to fish maturity-at-length data.
#'
#' Function requires observed length and maturity category
#' (0=immature, 1=mature) data for individual fish (stored in memory in R).
#' ObsLen, ObsMatCat (Numeric Vectors)
#' @param length at maturity params L50 and L95 (Vector), observed lengths ObsLen (Vector),
#' maturity status at each age (0=immature, 1=mature) ObsMatCat (Vector), samples size for
#' each length class LenClSampSize (vector), midpoint of each length class midpt (Vector),
#' observed proportion mature in each length class PropMat (Vector), lengths for which line
#' is plotted plotlengths (Vector), axis scaliing parameters ymax, xmax, yint, xint (Numbers),
#' GraphTitle, xaxis_lab, yaxis_lab (Strings), PlotCLs (Logical)
#' @return fitted curve on scatter plot with maturity-at-length data
#' @examples
#' # Generate some synthetic length at maturity data
#' MaxAge = 20
#' nSamples = 300
#' Linf = 300
#' vbK = 0.3
#' tzero = 0
#' CVSizeAtAge = 0.1
#' MinLen = 0
#' MaxLen = 400
#' LenInc = 20
#' L50 = 220
#' L95 = 270
#' res=SimulateLengthAtMaturityData(nSamples, MaxAge, Linf, vbK, tzero, MinLen, MaxLen, LenInc, L50, L95)
#' ObsLen=res$ObsLen
#' ObsMatCat=res$ObsMatCat
#' midpt=res$midpt
#' plotlengths=res$plotlengths
#' LenClSampSize=res$LenClSampSize
#' PropMat=res$PropMat
#' params = c(L50, L95)
#' PlotFittedLengthAtMaturityCurve(params, ObsLen, ObsMatCat, LenClSampSize, midpt, PropMat, plotlengths,
#'                                 xmax=400, xint=50, GraphTitle=NA, xaxis_lab="Total length, mm",
#'                                 yaxis_lab="Prop. mature", PlotCLs=FALSE)
#' @export
PlotFittedLengthAtMaturityCurve <- function(params, ObsLen, ObsMatCat, LenClSampSize, midpt, PropMat, plotlengths, xmax, xint,
                                            GraphTitle, xaxis_lab, yaxis_lab, PlotCLs) {

  if (is.na(xmax)) {
    xmax = 50 + trunc(ceiling(max(ObsLen))/50)*50
  }
  if (is.na(xint)) {
    xint = 50
  }
  if (is.na(xaxis_lab)) {
    xaxis_lab = "Total length, mm"
  }
  if (is.na(yaxis_lab)) {
    yaxis_lab = "Prop. mature"
  }

  # get parameter estimates
  LogisticModType = 1 # length at maturity
  ObsAgeCl = NA
  res = GetLogisticMaturityCurveResults(params, LogisticModType, ObsLen, ObsAgeCl, ObsMatCat)
  L50 = res$ParamEst[1]
  L95 = res$ParamEst[2]
  params = c(L50,L95)

  # plot data
  plot(midpt,PropMat, xlim=c(0,xmax), ylim=c(0,1.2),
       frame=F, xaxt='n', yaxt='n', xlab="", ylab="", main=GraphTitle)
  axis(1,at=seq(0,xmax,xint),line=0.2, labels=F)
  axis(2,at=seq(0,1,0.2), line=0.2, labels=F)
  axis(1,at=seq(0,xmax,xint),lwd=0, labels=T, line=0,cex.axis=0.8, las=1)
  axis(2,at=seq(0,1,0.2), lwd=0, labels=T, line=0,cex.axis=0.8, las=1)
  mtext("Total length (mm)",1,line=2.5)
  mtext("Proportion mature          ",2,line=2.5)
  text(midpt,1.1,LenClSampSize,cex=0.7)
  legend(0.025*xmax,0.975, pch=c(1,16), legend=c("Observed", "Est. L50"), lty="solid",
         bty='n', cex=0.6,lwd=-1, y.intersp=1.5)

  if (PlotCLs == FALSE) {
    # calculate probabilities for specified lengths, given parameter estimates
    plotprobs = 1.0 / (1.0 + exp(- log(19) * (plotlengths - L50) / (L95 - L50)))
    lines(plotlengths, plotprobs)
    points(L50,0.5,pch=16,col="black")
  } else {

    # get data for confidence limits
    vcov.params = res$vcov.params
    res = GetConfidenceLimitsForMaturityCurve(params, vcov.params, LogisticModType, plotlengths, plotages=NA)

    # plot confidence limits
    lw=min(plotlengths)
    hi = max(plotlengths)
    x = c(lw:hi,hi:lw) # using shading for 95% CLs
    y = c(res$sim.mat.low,rev(res$sim.mat.up))
    polygon(x,y,col="light grey",border=NA)
    lines(plotlengths, res$sim.mat.est, "l", lty="solid")
    lines(plotlengths, res$sim.mat.low, "l", lty="dotted")
    lines(plotlengths, res$sim.mat.up, "l", lty="dotted")
    points(midpt,PropMat)
    points(L50,0.5,pch=16,col="black")
  } # else PlotCLs
} # end function

#' Plot fitted logistic curve to fish maturity-at-age data.
#'
#' Function requires observed age and maturity category
#' (0=immature, 1=mature) data for individual fish (stored in memory in R).
#' ObsLen, ObsMatCat (Numeric Vectors)
#' @param age at maturity params A50 and A95 (Vector), observed age classes ObsAgeCl (Vector),
#' maturity status at each age (0=immature, 1=mature) ObsMatCat (Vector), ageclasses for analysis AgeCl (Vector),
#' sample size for each age class AgeClSampSize (vector), observed proportion mature in each age class
#' PropMat (Vector), ages for which line is plotted plotages (Vector), axis scaling parameters ymax, xmax, yint, xint (Numbers),
#' GraphTitle, xaxis_lab, yaxis_lab (Strings), PlotCLs (Logical)
#' @return fitted curve on scatter plot with maturity-at-length data
#' @examples
#' # generate some synthetic age at maturity data
#' MinAge = 0
#' MaxAge = 20
#' nSamples = 300
#' A50 = 4
#' A95 = 6
#' res=SimulateAgeAtMaturityData(nSamples, MinAge, MaxAge, A50, A95)
#' ObsAgeCl=res$ObsAgeCl
#' ObsMatCat=res$ObsMatCat
#' AgeCl = MinAge:MaxAge
#' plotages = res$plotages
#' PropMat = res$PropMat
#' AgeClSampSize=res$AgeClSampSize
#' xmax=MaxAge
#' xint=2
#' GraphTitle=NA
#' xaxis_lab=NA
#' yaxis_lab=NA
#' params = c(A50, A95)
#' PlotFittedAgeAtMaturityCurve(params, ObsAgeCl, ObsMatCat, AgeCl, PropMat, AgeClSampSize, plotages,
#' xmax=20, xint=2, GraphTitle=NA, xaxis_lab="Total length, mm",
#' yaxis_lab="Prop. mature", PlotCLs=FALSE)
#' @export
PlotFittedAgeAtMaturityCurve <- function(params, ObsAgeCl, ObsMatCat, AgeCl, PropMat, AgeClSampSize, plotages,
                                         xmax, xint, GraphTitle, xaxis_lab, yaxis_lab, PlotCLs) {

  if (is.na(xmax)) {
    xmax = 2 + trunc(ceiling(max(ObsAgeCl))/2)*2
  }
  if (is.na(xint)) {
    xint = 2
  }
  if (is.na(xaxis_lab)) {
    xaxis_lab = "Age, y"
  }
  if (is.na(yaxis_lab)) {
    yaxis_lab = "Prop. mature"
  }

  # get parameter estimates
  LogisticModType = 2 # Age at maturity
  ObsLen=NA
  res = GetLogisticMaturityCurveResults(params, LogisticModType, ObsLen, ObsAgeCl, ObsMatCat)
  A50 = res$ParamEst[1]
  A95 = res$ParamEst[2]
  params = c(A50,A95)

  # plot data
  plot(AgeCl,PropMat, xlim=c(0,xmax), ylim=c(0,1.2),
       frame=F, xaxt='n', yaxt='n', xlab="", ylab="", main=GraphTitle)
  axis(1,at=seq(0,xmax,xint),line=0.2, labels=F)
  axis(2,at=seq(0,1,0.2), line=0.2, labels=F)
  axis(1,at=seq(0,xmax,xint),lwd=0, labels=T, line=0,cex.axis=0.8, las=1)
  axis(2,at=seq(0,1,0.2), lwd=0, labels=T, line=0,cex.axis=0.8, las=1)
  mtext("Age, y",1,line=2.5)
  mtext("Proportion mature          ",2,line=2.5)
  text(AgeCl,1.1,AgeClSampSize,cex=0.7)
  legend(0.025*xmax,0.975, pch=c(1,16), legend=c("Observed", "Est. A50"), lty="solid",
         bty='n', cex=0.6,lwd=-1, y.intersp=1.5)

  if (PlotCLs == FALSE) {
    # calculate probabilities for specified lengths, given parameter estimates
    plotprobs = 1.0 / (1.0 + exp(- log(19) * (plotages - A50) / (A95 - A50)))
    lines(plotages, plotprobs)
    points(A50,0.5,pch=16,col="black")
  } else {

    # get data for confidence limits
    vcov.params = res$vcov.params
    res = GetConfidenceLimitsForMaturityCurve(params, vcov.params, LogisticModType, plotlengths=NA, plotages)

    # plot confidence limits
    x1 = plotages
    x2 = rev(plotages)
    x = c(x1,x2) # using shading for 95% CLs
    y = c(res$sim.mat.low,rev(res$sim.mat.up))
    polygon(x,y,col="light grey",border=NA)
    lines(plotages, res$sim.mat.est, "l", lty="solid")
    lines(plotages, res$sim.mat.low, "l", lty="dotted")
    lines(plotages, res$sim.mat.up, "l", lty="dotted")
    points(AgeCl,PropMat)
    points(A50,0.5,pch=16,col="black")
  } # else PlotCLs
} # end function


# ***************************
# Weight-length relationships
# ***************************

#' Simulate weight-length data
#'
#' @param params  number of required samples, nsamples (number), minimum length,
#' minlen (number), maxlen (number), weight length equation parameters, lenwt_a
#' (number), lenwt_b (number), standard deviation of data in log space, sd (Number)
#' @return randomly-generated fish lengths, FishLen (Vector), randomly-generated
#' fish weights, FishWt (Vector)
#' @examples
#' # generate synthetic data
#' set.seed(123)
#' nsamples = 100
#' minlen = 20
#' maxlen = 500
#' lenwt_a = 0.00002
#' lenwt_b = 3
#' lenwt_sd = 0.1
#' Res = SimulateWeightLengthData(nsamples, minlen, maxlen,
#'                                lenwt_a, lenwt_b, lenwt_sd)
#' Res
#' @export
SimulateWeightLengthData <- function(nsamples, minlen, maxlen,
                                     lenwt_a, lenwt_b, lenwt_sd) {

  plotlen = seq(minlen, maxlen, 1)
  plotwt = lenwt_a * plotlen ^ lenwt_b
  rand_len = round(runif(nsamples, minlen, maxlen),0)
  exp_wt = lenwt_a * rand_len ^ lenwt_b
  rand_err = rnorm(nsamples, 0, lenwt_sd)
  rand_wt = exp_wt * exp(rand_err) * exp(0.5 * lenwt_sd ^ 2)

  Results = list(FishLen=rand_len,
                 FishWt=rand_wt)
  return(Results)

}


#' fit weight-length relationship and get parameter estimates
#'
#' @param params  FishLen, FishWt (Numeric Vectors)
#' @return weight-length parameters with associated 95 percent confidence limits, adjusted R2,
#' sample size, Resid_var
#' @examples
#' # generate synthetic data
#' nsamples = 100
#' minlen = 20
#' maxlen = 500
#' lenwt_a = 0.00002
#' lenwt_b = 3
#' lenwt_sd = 0.1
#' Res = SimulateWeightLengthData(nsamples, minlen, maxlen,
#'                                lenwt_a, lenwt_b, lenwt_sd)
#' FishLen=Res$FishLen
#' FishWt=Res$FishWt
#' # Fit weight-length relationship and get results
#' GetWeightLengthRegressionResults(FishLen, FishWt)
#' @export
GetWeightLengthRegressionResults <- function(FishLen, FishWt) {

  # do linear regression, using lm function
  ln_len = log(FishLen)
  ln_wt = log(FishWt)
  dat = data.frame(ln_len, ln_wt)
  mod1 = lm(ln_wt ~ ln_len, data=dat)
  out=summary(mod1)

  # get parameter estimates and 95% confidence limits
  log_a = out$coefficients[1,1]
  log_a_se = out$coefficients[1,2]
  b = out$coefficients[2,1]
  b_se = out$coefficients[2,2]
  ln_lenwt_a = c(log_a, log_a + c(-1.96,1.96) * log_a_se)
  lenwt_b = c(b, b + c(-1.96,1.96) * b_se)
  ParamEst = t(data.frame(ln_lenwt_a=round(ln_lenwt_a,3), lenwt_b=round(lenwt_b,3)))
  colnames(ParamEst) = c("Estimate","lw_95%CL","up_95%CL")

  # get R2
  adj.r.squared = out$adj.r.squared

  # get sample size
  sampsize = length(FishLen)

  # get residual variance
  Resid_var = (summary(mod1)$sigma)^2

  # get estimated weights, in log space, for sequential (logged) fish length values within range of x data
  max_lnlen = max(ln_len)
  min_lnlen = min(ln_len)
  plot_lnlen = seq(min_lnlen, max_lnlen, 0.1)
  plot_lnwt = (log_a + b * plot_lnlen)

  # get 95% confidence limits
  newdat <- data.frame(ln_len=plot_lnlen)
  conf_int = predict(mod1, newdata = newdat, interval = 'confidence')
  pred_int = predict(mod1, newdata = newdat, interval = 'predict')

  results = list(mod1 = mod1,
                 ParamEst = ParamEst,
                 adj.r.squared = adj.r.squared,
                 plot_lnlen = plot_lnlen,
                 plot_lnwt = plot_lnwt,
                 conf_int = conf_int,
                 pred_int = pred_int,
                 Resid_var=Resid_var)

  return(results)
}

#'plot weight length relationship over data in normal space
#'
#' @param params  FishLen, FishWt (Numeric Vectors), xmin, ymin, xmax, ymax, xint, yint, (Numbers),
#'      GraphTitle, xaxis_lab, yaxis_lab (Strings), PlotCLs (Logical)
#' @return fitted curve on scatter plot with weight-length data
#' @examples
#' # generate synthetic data
#' nsamples = 100
#' minlen = 20
#' maxlen = 500
#' lenwt_a = 0.00002
#' lenwt_b = 3
#' lenwt_sd = 0.1
#' Res = SimulateWeightLengthData(nsamples, minlen, maxlen,
#'                                lenwt_a, lenwt_b, lenwt_sd)
#' FishLen=Res$FishLen
#' FishWt=Res$FishWt
#' # Fit weight-length relationship and plot results (in normal space)
#' PlotWeightLengthRel_NormalSpace(FishLen, FishWt, xmin=NA, ymin=NA, xmax=NA, ymax=NA, xint=NA, yint=NA,
#' GraphTitle=NA, xaxis_lab=NA, yaxis_lab=NA, PlotCLs=T)
#' @export
PlotWeightLengthRel_NormalSpace <- function(FishLen, FishWt, xmin, ymin, xmax, ymax, xint, yint,
                                            GraphTitle, xaxis_lab, yaxis_lab, PlotCLs) {

  # get regression analysis results
  res = GetWeightLengthRegressionResults(FishLen, FishWt)

  # get default axis limits and intervals
  ylims=Get_yaxis_scale(FishWt)
  xlims=Get_xaxis_scale(FishLen)

  if (is.na(xmin)) {
    xmin = xlims$xmin
  }
  if (is.na(xmax)) {
    xmax = xlims$xmax
  }
  if (is.na(xint)) {
    xint = xlims$xint
  }

  if (is.na(ymin)) {
    ymin = ylims$ymin
  }
  if (is.na(ymax)) {
    ymax = ylims$ymax
  }
  if (is.na(yint)) {
    yint = ylims$yint
  }

  if (is.na(xaxis_lab)) {
    xaxis_lab = "Length, mm"
  }
  if (is.na(yaxis_lab)) {
    yaxis_lab = "Weight, g"
  }


  # plot in normal space (with bias correction applied)
  plot(FishLen, FishWt, pch=16, cex=0.5, bty='n', ylim=c(0,ymax), xlim=c(0,xmax), xaxt='n', yaxt='n',
       ylab="", xlab="", main=GraphTitle, cex.main=0.8)
  axis(1,at=seq(0,xmax,xint), cex.axis=0.8, lwd=1.75,lab=F) # y axis
  axis(2,at=seq(0,ymax,yint), cex.axis=0.8, lwd=1.75,lab=F) # y axis
  axis(1,at=seq(0,xmax,xint), labels=seq(0,xmax,xint),cex.axis=0.8,line=0,las=1,lwd=1.5,tick=F) #add y labels
  axis(2,at=seq(0,ymax,yint), cex.axis=0.8,line=0,las = 1,lwd=1.5,tick=F) #add y labels
  mtext(expression(paste(plain("Length (mm"),plain(")"))),las=3,side=2,line=3,cex=1,lwd=1.75)
  mtext(expression(paste(plain("Weight (g"),plain(")"))),las=1,side=1,line=3,cex=1,lwd=1.75)
  # lines(exp(res$plot_lnlen), exp(res$conf_int[,1]), col="black", lty="dotted") # without bias correction
  lines(exp(res$plot_lnlen), exp(res$conf_int[,1]) * exp(0.5*res$Resid_var), col="black", lty="solid")

  if (PlotCLs == T) {
    lines(exp(res$plot_lnlen), exp(res$conf_int[,2]) * exp(0.5*res$Resid_var), col="dark grey", lty="dashed")
    lines(exp(res$plot_lnlen), exp(res$conf_int[,3]) * exp(0.5*res$Resid_var), col="dark grey", lty="dashed")
    lines(exp(res$plot_lnlen), exp(res$pred_int[,2]) * exp(0.5*res$Resid_var), col="blue", lty="dotted")
    lines(exp(res$plot_lnlen), exp(res$pred_int[,3]) * exp(0.5*res$Resid_var), col="blue", lty="dotted")
    legend(0.05*xmax, 0.95*ymax, pch=c(1,16), legend=c("Estimate", "low 95% CL", "up 95% CL", "low 95% PL", "up 95% PL"),
           lty=c("solid","dashed","dashed","dotted","dotted"),
           col=c("black","dark grey","dark grey","blue","blue"),
           bty='n', cex=0.6,lwd=1, y.intersp=1.5)
  }
}

#'plot weight length relationship over data in log space
#'
#' @param params  FishLen, FishWt (Numeric Vectors), xmin, ymin, xmax, ymax, xint, yint, (Numbers),
#'      GraphTitle, xaxis_lab, yaxis_lab (Strings), PlotCLs (Logical)
#' @return fitted curve on scatter plot with weight-length data
#' @examples
#' # generate synthetic data
#' nsamples = 100
#' minlen = 20
#' maxlen = 500
#' lenwt_a = 0.00002
#' lenwt_b = 3
#' lenwt_sd = 0.1
#' Res = SimulateWeightLengthData(nsamples, minlen, maxlen,
#'                                lenwt_a, lenwt_b, lenwt_sd)
#' FishLen=Res$FishLen
#' FishWt=Res$FishWt
#' # Fit weight-length relationship and plot results (in log space)
#' PlotWeightLengthRel_LogSpace(FishLen, FishWt, xmin=NA, ymin=NA, xmax=NA, ymax=NA, xint=NA, yint=NA,
#' GraphTitle=NA, xaxis_lab=NA, yaxis_lab=NA, PlotCLs=T)
#' @export
PlotWeightLengthRel_LogSpace <- function(FishLen, FishWt, xmin, ymin, xmax, ymax, xint, yint,
                                         GraphTitle, xaxis_lab, yaxis_lab, PlotCLs) {

  # get regression analysis results
  res = GetWeightLengthRegressionResults(FishLen, FishWt)

  # get default axis limits and intervals
  ylims=Get_yaxis_scale(log(FishWt))
  xlims=Get_xaxis_scale(log(FishLen))

  if (is.na(xmin)) {
    xmin = xlims$xmin
  }
  if (is.na(xmax)) {
    xmax = xlims$xmax
  }
  if (is.na(xint)) {
    xint = xlims$xint
  }

  if (is.na(ymin)) {
    ymin = ylims$ymin
  }
  if (is.na(ymax)) {
    ymax = ylims$ymax
  }
  if (is.na(yint)) {
    yint = ylims$yint
  }

  if (is.na(xaxis_lab)) {
    xaxis_lab = "ln Length, mm"
  }
  if (is.na(yaxis_lab)) {
    yaxis_lab = "ln Weight, g"
  }

  # plot in log space
  plot(log(FishLen), log(FishWt), pch=16, cex=0.5, bty='n', ylim=c(ymin,ymax), xlim=c(xmin,xmax), xaxt='n', yaxt='n',
       ylab="", xlab="", main=GraphTitle, cex.main=0.8)
  axis(1,at=seq(xmin,xmax,xint), cex.axis=0.8, lwd=1.75,lab=F) # y axis
  axis(2,at=seq(ymin,ymax,yint), cex.axis=0.8, lwd=1.75,lab=F) # y axis
  axis(1,at=seq(xmin,xmax,xint), labels=seq(xmin,xmax,xint),cex.axis=0.8,line=0,las=1,lwd=1.5,tick=F) #add y labels
  axis(2,at=seq(ymin,ymax,yint), cex.axis=0.8,line=0,las = 1,lwd=1.5,tick=F) #add y labels
  mtext(xaxis_lab,las=3,side=2,line=3,cex=1,lwd=1.75)
  mtext(yaxis_lab,las=1,side=1,line=3,cex=1,lwd=1.75)
  lines(res$plot_lnlen, res$conf_int[,1], col="black", lty="solid")

  if (PlotCLs == T) {
    lines(res$plot_lnlen, res$conf_int[,2], col="dark grey", lty="dashed")
    lines(res$plot_lnlen, res$conf_int[,3], col="dark grey", lty="dashed")
    lines(res$plot_lnlen, res$pred_int[,2], col="blue", lty="dotted")
    lines(res$plot_lnlen, res$pred_int[,3], col="blue", lty="dotted")
    legend(1.05*xmin, 0.95*ymax, pch=c(1,16), legend=c("Estimate", "low 95% CL", "up 95% CL", "low 95% PL", "up 95% PL"),
           lty=c("solid","dashed","dashed","dotted","dotted"),
           col=c("black","dark grey","dark grey","blue","blue"),
           bty='n', cex=0.6,lwd=1, y.intersp=1.5)
  }
}


